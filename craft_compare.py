#!/usr/bin/env python3
"""
Craft comparison tool - calculates crafting efficiency for a given recipe, service, and gearset.
Similar to the "Craft Compare" sheet in Arky's spreadsheet.
"""

import math
from util.walkscape_constants import *
from util.gearset_utils import calculate_gear_stats
from util.collectibles_utils import calculate_collectible_stats
from util.recipe_materials import (
    get_recipe_materials_with_objects,
    calculate_material_cost,
    get_material_value
)
from util.quality_outcome import format_quality_table, calculate_quality_weights
from util.misc_utils import format_number
from my_config import get_character

# ============================================================================
# CONFIGURATION - Edit these values
# ============================================================================

RECIPE = Recipe.GOLD_BAR  # Use Recipe.RECIPE_NAME
SERVICE = Service.TIDAL_WORKSHOP_VASTALUME  # Use Service.SERVICE_NAME_LOCATION
GEARSET_EXPORT = "H4sIAAAAAAAAE82W227bMAyGX6XIdQnofNirLIVBSVTi1bEz22kXFH330e3Fhi4o3CIFdhFbkEX7y6+fpJ427UyHafPt5vvTZj4fiUebPWHZ3N5s2r7QL54Qy5iXLc+etpu2bHm0fZmC/bmMbdeeDk1pH9p+1+ypO4DIUYVcEhD6BCY6D0lhBFmdIkzGSFJb/sR28/OEXTufX9844kiv0zPulqn+1HXPCwqN4zC+YN493978Qc3I95Woy9pmqM0euwqY9y090AhZMZKuHgqWAiYVDUhVQtU2VyWtlMVdQM3D4TD0H4NNmO/Xwi5rj/wDp6X1KQQQFCIYWQM/UwmiiLGQiTI6fSW+vKdp/vTGz/zOAVKKXtloQUjNuIUcJFktoAwGRQrVynIBt6Md9QXH88eIj2N74KC1zO049M30OIwFhKhIqBB8FgaM9oxYNEG2VeUgTFEKL3Ce+s8IO1EeXv7dWtBpJuqaiS3aFYjJey9TZQekxQFeQ/DOQha2BESi7OJVkmmPfZnWIu7G9ng8N7tueKAJqhLRRuNAk7ZglCi84yg4lbTyXpCni4yfEZOtshryH5Ny8I7vE6jsUaqsIdriOe2thuSIQFG1vhZVk7lOheppVdL7ZGTWxUEhrkBGJweh5gxROqtTsj5WupofK9HqPM8j1nmRLg3DPAELlap1GUIQBMaFpbJ7DwEV533Njv14pY0e+atrKYeuNLvlsgSBQh294abDNAjGspgojADtUklkk632UnJfA1L+j5DzMHRrlcTy4zTNmDpqHkfq8x6KiSYkgaB1CQxKFtisgp2KQZdYhczhi0DfU3Pq2kLNeOq4iUslpFI1AnE3566TucF7rpgeBauotNb4VYjqHcQD7vq2nl8LTz8ROGISb4nPRUaCQR0ADXFRX7qmd6hzvNQdr8Gp3zPmoW9hCQAvtCxGcQVyiveaOw6nN2+9ilkqi147Yb4I0LwDWLvhcVHxOOR7mh9xZltKl8kGlrFG4oMbcjmKli3go1ZRVe+zvNbB6C2q/Qt1CX4be/f8G7WFShhYCwAA"
CONSUMABLE = None # None for no consumable

# Target quality and quantity (for quality items)
TARGET_QUALITY = 'Perfect'  # 'Normal', 'Good', 'Great', 'Excellent', 'Perfect', 'Eternal'
TARGET_QUALITY_QUANTITY = 1  # How many of this quality to craft

# For simple items (non-quality items), choose ONE mode:
TARGET_QUANTITY = None  # How many simple items to craft (set to None to use MATERIAL_BUDGET instead)
MATERIAL_BUDGET = 102  # Or specify materials available and calculate max items (set to None to use TARGET_QUANTITY)

# Advanced options
USE_ITERATIVE_CALCULATION = True  # Account for level-ups during crafting (more accurate)

SHOW_ALL_ITEM_STATS = False  # Set to True to see item-by-item stat breakdown grouped by stat type
# Character export is loaded from my_config.py
# Edit CHARACTER_EXPORT in my_config.py to set your character data

# ============================================================================

def is_quality_item(recipe_name: str) -> bool:
    """Check if recipe produces a quality item (exists in equipment)."""
    try:
        from util.autogenerated.equipment import Item
        enum_name = recipe_name.upper().replace(' ', '_').replace('-', '_')
        return hasattr(Item, enum_name)
    except:
        return False

def calculate_crafting_stats_iterative(recipe, service, gearset_export, consumable=None, target_quality='Perfect', target_quantity=1, material_budget=None):
    """
    Calculate crafting stats with iterative level-up handling.
    Recalculates bonuses each time you level up during crafting.
    
    Returns same dict as calculate_crafting_stats but with level_progression list.
    """
    # Validate service matches recipe requirement
    if not service.is_valid_for_recipe(recipe):
        return {
            'error': f"Service mismatch: Recipe '{recipe.name}' requires '{recipe.service}' but got '{service.name}' ({service.category.value if hasattr(service.category, 'value') else service.category}, {service.tier})",
            'recipe': recipe.name,
            'service': service.name
        }
    
    character = get_character()
    current_xp = character.skills.get(recipe.skill.lower(), 0)
    current_level = xp_to_level(current_xp)
    
    is_quality = is_quality_item(recipe.name)
    
    # Get base stats that don't change with level
    location = service.location if service.location else None
    gear_stats, item_breakdown = calculate_gear_stats(gearset_export, recipe.skill, location, return_breakdown=True)
    
    service_stats_raw = service.get_stats_for_skill(service.category, location=service.location)
    service_stats = {
        'we': service_stats_raw.get('work_efficiency', 0.0),
        'dr': service_stats_raw.get('double_rewards', 0.0),
        'da': service_stats_raw.get('double_action', 0.0),
        'nmc': service_stats_raw.get('no_materials_consumed', 0.0),
        'qo': service_stats_raw.get('quality_outcome', 0.0),
        'bonus_xp_percent': service_stats_raw.get('bonus_xp_percent', 0.0),
        'bonus_xp_add': service_stats_raw.get('bonus_xp_add', 0.0)
    }
    
    collectible_stats = {'we': 0.0, 'dr': 0.0, 'da': 0.0, 'nmc': 0.0, 'qo': 0.0, 'bonus_xp_percent': 0.0, 'bonus_xp_add': 0.0}
    try:
        for collectible in character.collectibles:
            coll_stats = collectible.get_stats_for_skill(recipe.skill, location=service.location)
            collectible_stats['we'] += coll_stats.get('work_efficiency', 0.0)
            collectible_stats['dr'] += coll_stats.get('double_rewards', 0.0)
            collectible_stats['da'] += coll_stats.get('double_action', 0.0)
            collectible_stats['nmc'] += coll_stats.get('no_materials_consumed', 0.0)
            collectible_stats['qo'] += coll_stats.get('quality_outcome', 0.0)
            collectible_stats['bonus_xp_percent'] += coll_stats.get('bonus_xp_percent', 0.0)
            collectible_stats['bonus_xp_add'] += coll_stats.get('bonus_xp_add', 0.0)
    except:
        pass
    
    consumable_stats = {'we': 0.0, 'dr': 0.0, 'da': 0.0, 'nmc': 0.0, 'qo': 0.0, 'bonus_xp_percent': 0.0, 'bonus_xp_add': 0.0}
    if consumable:
        consumable_attrs = consumable.attr(recipe.skill)
        consumable_stats['we'] = consumable_attrs.get('work_efficiency', 0.0)
        consumable_stats['dr'] = consumable_attrs.get('double_rewards', 0.0)
        consumable_stats['da'] = consumable_attrs.get('double_action', 0.0)
        consumable_stats['nmc'] = consumable_attrs.get('no_materials_consumed', 0.0)
        consumable_stats['qo'] = consumable_attrs.get('quality_outcome', 0.0)
        consumable_stats['bonus_xp_percent'] = consumable_attrs.get('bonus_xp_percent', 0.0)
        consumable_stats['bonus_xp_add'] = consumable_attrs.get('bonus_xp_add', 0.0)
    
    # Track progress
    total_crafts_done = 0
    total_materials_used = 0.0
    total_steps_taken = 0.0
    total_xp_gained = 0.0
    level_progression = [(current_level, current_xp, 0, 0.0, 0.0)]
    
    # Determine target
    materials_remaining = material_budget if material_budget else float('inf')
    
    # Iterative crafting loop
    while True:
        # Calculate level bonuses at current level
        current_level = xp_to_level(current_xp)
        levels_over_requirement = max(0, current_level - recipe.level)
        level_bonus_we = min(levels_over_requirement * 1.25, 25.0) / 100.0
        level_bonus_qo = levels_over_requirement
        
        # Calculate total stats at this level
        total_we = gear_stats['we'] + service_stats['we'] + collectible_stats['we'] + consumable_stats['we'] + level_bonus_we
        total_dr = gear_stats['dr'] + service_stats['dr'] + collectible_stats['dr'] + consumable_stats['dr']
        total_da = gear_stats['da'] + service_stats['da'] + collectible_stats['da'] + consumable_stats['da']
        total_nmc = gear_stats['nmc'] + service_stats['nmc'] + collectible_stats['nmc'] + consumable_stats['nmc']
        total_qo = gear_stats['qo'] + service_stats['qo'] + collectible_stats['qo'] + consumable_stats['qo'] + level_bonus_qo
        total_flat = gear_stats.get('flat', 0)
        total_pct = gear_stats.get('pct', 0.0)
        
        # Calculate efficiency and steps
        max_gear_efficiency = recipe.max_efficiency
        capped_we = min(total_we, max_gear_efficiency)
        total_efficiency = 1.0 + capped_we
        
        base_with_efficiency = recipe.base_steps / total_efficiency
        with_pct = base_with_efficiency * (1 + total_pct)
        current_steps = max(math.ceil(with_pct) + total_flat, 10)
        
        actions_per_completion = 1 + total_da
        reward_rolls_per_completion = (1 + total_da) * (1 + total_dr)
        steps_per_reward_roll = current_steps / reward_rolls_per_completion
        
        crafts_per_material = (1 + total_dr) / (1 - total_nmc) if total_nmc < 1.0 else float('inf')
        
        # Calculate XP to next level
        xp_to_next_level = level_to_xp(current_level + 1) - current_xp
        crafts_to_next_level = xp_to_next_level / recipe.base_xp
        
        # Determine target crafts remaining
        if is_quality:
            quality_result = calculate_quality_weights(recipe.level, total_qo)
            target_weight = quality_result['weights'][target_quality]
            total_weight = quality_result['total_weight']
            crafts_for_one = math.ceil(total_weight / target_weight) if target_weight > 0 else float('inf')
            remaining_for_target = crafts_for_one * target_quantity - total_crafts_done
        else:
            if target_quantity:
                remaining_for_target = target_quantity - total_crafts_done
            else:
                remaining_for_target = float('inf')
        
        # Determine how many crafts we can do with remaining materials
        materials_available_crafts = materials_remaining * crafts_per_material
        
        # Craft the minimum of: target remaining, next level, materials available
        crafts_this_iteration = min(remaining_for_target, crafts_to_next_level, materials_available_crafts)
        
        # Stop if we can't craft anymore
        if crafts_this_iteration <= 0:
            break
        
        # Do the crafts
        materials_this_iteration = crafts_this_iteration / crafts_per_material
        steps_this_iteration = steps_per_reward_roll * crafts_this_iteration
        
        # Calculate XP using XP/step formula
        # xp_per_step = ((base_xp * (1 + xp_pct)) + xp_add) * (actions_per_completion) / current_steps
        total_bonus_xp_percent = gear_stats.get('bonus_xp_percent', 0.0) + service_stats.get('bonus_xp_percent', 0.0) + collectible_stats.get('bonus_xp_percent', 0.0) + consumable_stats.get('bonus_xp_percent', 0.0)
        total_bonus_xp_add = gear_stats.get('bonus_xp_add', 0.0) + service_stats.get('bonus_xp_add', 0.0) + collectible_stats.get('bonus_xp_add', 0.0) + consumable_stats.get('bonus_xp_add', 0.0)
        xp_per_step = ((recipe.base_xp * (1 + total_bonus_xp_percent)) + total_bonus_xp_add) * actions_per_completion / current_steps
        xp_this_iteration = xp_per_step * steps_this_iteration
        
        # Update totals
        total_crafts_done += crafts_this_iteration
        total_materials_used += materials_this_iteration
        total_steps_taken += steps_this_iteration
        total_xp_gained += xp_this_iteration
        current_xp += xp_this_iteration
        materials_remaining -= materials_this_iteration
        
        # Check if we leveled up
        new_level = xp_to_level(current_xp)
        if new_level > current_level:
            level_progression.append((new_level, current_xp, total_crafts_done, total_materials_used, total_steps_taken))
        
        # Check if we're done
        if is_quality:
            if total_crafts_done >= crafts_for_one * target_quantity:
                break
        else:
            if target_quantity and total_crafts_done >= target_quantity:
                break
        
        if materials_remaining <= 0:
            break
        
        # Safety check
        if len(level_progression) > 100:
            break
    
    # Build final stats dict
    final_level = xp_to_level(current_xp)
    
    # Calculate final level stats for display
    final_level_bonus_we = min(max(0, final_level - recipe.level) * 1.25, 25.0) / 100.0
    final_total_we = gear_stats['we'] + service_stats['we'] + collectible_stats['we'] + consumable_stats['we'] + final_level_bonus_we
    final_total_dr = gear_stats['dr'] + service_stats['dr'] + collectible_stats['dr'] + consumable_stats['dr']
    final_total_da = gear_stats['da'] + service_stats['da'] + collectible_stats['da'] + consumable_stats['da']
    final_total_nmc = gear_stats['nmc'] + service_stats['nmc'] + collectible_stats['nmc'] + consumable_stats['nmc']
    final_total_flat = gear_stats.get('flat', 0)
    final_total_pct = gear_stats.get('pct', 0.0)
    
    # Calculate final efficiency and steps
    final_capped_we = min(final_total_we, recipe.max_efficiency)
    final_total_efficiency = 1.0 + final_capped_we
    final_base_with_efficiency = recipe.base_steps / final_total_efficiency
    final_with_pct = final_base_with_efficiency * (1 + final_total_pct)
    final_current_steps = max(math.ceil(final_with_pct) + final_total_flat, 10)
    
    final_actions_per_completion = 1 + final_total_da
    final_reward_rolls_per_completion = (1 + final_total_da) * (1 + final_total_dr)
    final_steps_per_action = final_current_steps / final_actions_per_completion
    final_steps_per_reward_roll = final_current_steps / final_reward_rolls_per_completion
    
    return {
        'recipe': recipe.name,
        'recipe_obj': recipe,  # Add recipe object for material alternatives
        'skill': recipe.skill,
        'level_required': recipe.level,
        'skill_level': character.get_skill_level(recipe.skill),
        'final_level': final_level,
        'service': service.name,
        'location': service.location.name if service.location else 'Global',
        
        # Base stats
        'base_steps': recipe.base_steps,
        'base_xp': recipe.base_xp,
        'max_efficiency': recipe.max_efficiency,
        
        # Gear stats (use final level stats)
        'gear_we': gear_stats['we'] * 100,
        'gear_dr': gear_stats['dr'] * 100,
        'gear_da': gear_stats['da'] * 100,
        'gear_nmc': gear_stats['nmc'] * 100,
        'gear_qo': gear_stats['qo'],
        'gear_flat': gear_stats.get('flat', 0),
        'gear_pct': gear_stats.get('pct', 0.0) * 100,
        
        # Service stats
        'service_we': service_stats['we'] * 100,
        'service_dr': service_stats['dr'] * 100,
        'service_da': service_stats['da'] * 100,
        'service_nmc': service_stats['nmc'] * 100,
        'service_qo': service_stats['qo'],
        
        # Collectible stats
        'collectible_we': collectible_stats['we'] * 100,
        'collectible_dr': collectible_stats['dr'] * 100,
        'collectible_nmc': collectible_stats['nmc'] * 100,
        'collectible_qo': collectible_stats['qo'],
        
        # Consumable stats
        'consumable_we': consumable_stats['we'] * 100,
        'consumable_dr': consumable_stats['dr'] * 100,
        'consumable_da': consumable_stats['da'] * 100,
        'consumable_nmc': consumable_stats['nmc'] * 100,
        'consumable_qo': consumable_stats['qo'],
        'consumable_name': consumable.name if consumable else None,
        'consumable_duration': consumable.duration if consumable else None,
        
        # Level bonuses (at final level)
        'level_bonus_we': min(max(0, final_level - recipe.level) * 1.25, 25.0),
        'level_bonus_qo': max(0, final_level - recipe.level),
        
        # Total stats (at final level)
        'total_we': (gear_stats['we'] + service_stats['we'] + collectible_stats['we'] + consumable_stats['we'] + min(max(0, final_level - recipe.level) * 1.25, 25.0) / 100.0) * 100,
        'total_dr': (gear_stats['dr'] + service_stats['dr'] + collectible_stats['dr'] + consumable_stats['dr']) * 100,
        'total_da': (gear_stats['da'] + service_stats['da'] + collectible_stats['da'] + consumable_stats['da']) * 100,
        'total_nmc': (gear_stats['nmc'] + service_stats['nmc'] + collectible_stats['nmc'] + consumable_stats['nmc']) * 100,
        'total_qo': gear_stats['qo'] + service_stats['qo'] + collectible_stats['qo'] + consumable_stats['qo'] + max(0, final_level - recipe.level),
        
        # Calculated values (at final level)
        'current_gear_efficiency': gear_stats['we'] * 100,
        'total_efficiency': (final_total_efficiency - 1.0) * 100,
        'current_steps': final_current_steps,
        'actions_per_completion': final_actions_per_completion,
        'reward_rolls_per_completion': final_reward_rolls_per_completion,
        'steps_per_action': final_steps_per_action,
        'steps_per_reward_roll': total_steps_taken / total_crafts_done if total_crafts_done > 0 else final_steps_per_reward_roll,
        'crafts_per_material': total_crafts_done / total_materials_used if total_materials_used > 0 else 0,
        'normal_xp_per_step': total_xp_gained / total_steps_taken if total_steps_taken > 0 else 0,
        
        # Totals
        'target_crafts': total_crafts_done,
        'materials_needed': total_materials_used,
        'steps_for_target': total_steps_taken,
        'total_xp_gained': total_xp_gained,
        'current_skill_xp': character.skills.get(recipe.skill.lower(), 0),
        'final_skill_xp': current_xp,
        
        # Target info
        'is_quality_item': is_quality,
        'target_quality': target_quality if is_quality else None,
        'target_quantity': target_quantity,
        'material_budget': material_budget,
        'expected_items_from_budget': total_crafts_done if material_budget else None,
        
        # Materials
        'materials': recipe.materials,
        'materials_with_objects': get_recipe_materials_with_objects(recipe, prefer_cheapest=True),
        'material_cost_per_craft': calculate_material_cost(recipe, prefer_cheapest=True),
        'material_cost_for_target': None,
        
        # Level progression
        'level_progression': level_progression,
        'used_iterative': True,
        
        # Item breakdown
        'item_breakdown': item_breakdown
    }

def calculate_crafting_stats(recipe, service, gearset_export, consumable=None, target_quality='Perfect', target_quantity=1, material_budget=None):
    """
    Calculate crafting statistics for a recipe with given gearset and service.
    
    Args:
        recipe: Recipe object
        service: Service object
        gearset_export: Gearset export string
        consumable: Optional consumable to include
        target_quality: Target quality for quality items (Perfect, Excellent, etc.)
        target_quantity: Number of target quality items to craft
        material_budget: Optional material budget to calculate from
        
    Returns:
        Dict with all crafting statistics
    """
    # Validate service matches recipe requirement
    if not service.is_valid_for_recipe(recipe):
        return {
            'error': f"Service mismatch: Recipe '{recipe.name}' requires '{recipe.service}' but got '{service.name}' ({service.category.value if hasattr(service.category, 'value') else service.category}, {service.tier})",
            'recipe': recipe.name,
            'service': service.name
        }
    
    character = get_character()
    
    # Convert LocationInfo to string name
    location = service.location if service.location else None
    
    # Get skill level from character export if not provided
    try:
        character = get_character()
        skill_level = character.get_skill_level(recipe.skill)
    except Exception as e:
        return {'error': f'Must provide skill_level or configure CHARACTER_EXPORT in my_config.py: {e}'}
    
    # Calculate gear stats with item breakdown
    try:
        gear_stats, item_breakdown = calculate_gear_stats(gearset_export, recipe.skill, location, return_breakdown=True)
    except Exception as e:
        return {'error': f'Failed to calculate gear stats: {e}'}
    
    # Calculate service stats using mixin
    service_stats_raw = service.get_stats_for_skill(service.category, location=service.location)
    service_stats = {
        'we': service_stats_raw.get('work_efficiency', 0.0),
        'dr': service_stats_raw.get('double_rewards', 0.0),
        'da': service_stats_raw.get('double_action', 0.0),
        'nmc': service_stats_raw.get('no_materials_consumed', 0.0),
        'qo': service_stats_raw.get('quality_outcome', 0.0),
        'bonus_xp_percent': service_stats_raw.get('bonus_xp_percent', 0.0),
        'bonus_xp_add': service_stats_raw.get('bonus_xp_add', 0.0)
    }
    
    # Calculate collectible stats from character using StatsMixin
    collectible_stats = {'we': 0.0, 'dr': 0.0, 'da': 0.0, 'nmc': 0.0, 'qo': 0.0, 'bonus_xp_percent': 0.0, 'bonus_xp_add': 0.0}
    try:
        character = get_character()
        for collectible in character.collectibles:
            coll_stats = collectible.get_stats_for_skill(recipe.skill, location=service.location)
            collectible_stats['we'] += coll_stats.get('work_efficiency', 0.0)
            collectible_stats['dr'] += coll_stats.get('double_rewards', 0.0)
            collectible_stats['da'] += coll_stats.get('double_action', 0.0)
            collectible_stats['nmc'] += coll_stats.get('no_materials_consumed', 0.0)
            collectible_stats['qo'] += coll_stats.get('quality_outcome', 0.0)
            collectible_stats['bonus_xp_percent'] += coll_stats.get('bonus_xp_percent', 0.0)
            collectible_stats['bonus_xp_add'] += coll_stats.get('bonus_xp_add', 0.0)
    except Exception as e:
        # If character not configured, use empty stats
        pass
    
    # Calculate consumable stats if provided
    consumable_stats = {'we': 0.0, 'dr': 0.0, 'da': 0.0, 'nmc': 0.0, 'qo': 0.0, 'bonus_xp_percent': 0.0, 'bonus_xp_add': 0.0}
    if consumable:
        consumable_attrs = consumable.attr(recipe.skill)
        consumable_stats['we'] = consumable_attrs.get('work_efficiency', 0.0)
        consumable_stats['dr'] = consumable_attrs.get('double_rewards', 0.0)
        consumable_stats['da'] = consumable_attrs.get('double_action', 0.0)
        consumable_stats['nmc'] = consumable_attrs.get('no_materials_consumed', 0.0)
        consumable_stats['qo'] = consumable_attrs.get('quality_outcome', 0.0)
        consumable_stats['bonus_xp_percent'] = consumable_attrs.get('bonus_xp_percent', 0.0)
        consumable_stats['bonus_xp_add'] = consumable_attrs.get('bonus_xp_add', 0.0)
    
    # Calculate level bonuses
    # Work Efficiency: +1.25% per level above requirement, capped at 25%
    levels_over_requirement = max(0, skill_level - recipe.level)
    level_bonus_we = min(levels_over_requirement * 1.25, 25.0)
    
    # Quality Outcome: +1 per level above recipe requirement (no cap)
    level_bonus_qo = levels_over_requirement
    
    # Combine stats (all stats are now in decimal format from mixin: 0.05 = 5%)
    total_we = gear_stats['we'] + service_stats['we'] + collectible_stats['we'] + consumable_stats['we'] + (level_bonus_we / 100.0)
    total_dr = gear_stats['dr'] + service_stats['dr'] + collectible_stats['dr'] + consumable_stats['dr']
    total_da = gear_stats['da'] + service_stats['da'] + collectible_stats.get('da', 0.0) + consumable_stats['da']
    total_nmc = gear_stats['nmc'] + service_stats['nmc'] + collectible_stats['nmc'] + consumable_stats['nmc']
    total_qo = gear_stats['qo'] + service_stats['qo'] + collectible_stats['qo'] + consumable_stats['qo'] + level_bonus_qo
    total_flat = gear_stats.get('flat', 0)  # Flat steps modifier
    total_pct = gear_stats.get('pct', 0.0)  # Percentage steps modifier (already decimal)
    
    # Stats are already in decimal format (no conversion needed)
    dr_decimal = total_dr
    nmc_decimal = total_nmc
    
    # Calculate max gear efficiency (from recipe) - convert to decimal
    max_gear_efficiency = recipe.max_efficiency
    
    # Current gear efficiency is just gear WE (not including service)
    current_gear_efficiency = gear_stats['we']
    
    # Cap total WE at max efficiency
    capped_we = min(total_we, max_gear_efficiency)
    
    # Calculate total efficiency (base 100% + capped WE)
    total_efficiency = 1.0 + capped_we
    
    # EXACT FORMULAS FROM ONLINE TOOL:
    
    # Current displayed steps (this is the base steps after efficiency)
    # Formula: max(CEILING(max((base_steps/total_eff), min_steps) * (1 - pct_steps)) - flat_steps, 10)
    base_with_efficiency = recipe.base_steps / total_efficiency
    # total_pct is stored as negative (e.g., -0.01 for -1% steps), so we add it
    with_pct = base_with_efficiency * (1 + total_pct)
    current_steps = max(math.ceil(with_pct) + total_flat, 10)
    
    # Actions/Completion (or Crafts/Completion)
    # Formula: 1 + DA/100
    actions_per_completion = 1 + total_da
    
    # Reward rolls/completion
    # Formula: (1 + DA/100) * (1 + DR/100)
    reward_rolls_per_completion = (1 + total_da) * (1 + dr_decimal)
    
    # Steps/action
    # Formula: current_steps / (Actions/Completion)
    steps_per_action = current_steps / actions_per_completion
    
    # Steps/Reward Roll (or Steps/Craft)
    # Formula: current_steps / (Reward rolls/completion)
    steps_per_reward_roll = current_steps / reward_rolls_per_completion
    
    # Crafts/Material
    # Formula: (1 + DR/100) / (1 - NMC/100)
    crafts_per_material = (1 + dr_decimal) / (1 - nmc_decimal) if nmc_decimal < 1.0 else float('inf')
    
    # Determine if this is a quality item
    is_quality = is_quality_item(recipe.name)
    
    # Calculate expected crafts based on item type
    if is_quality:
        # Quality item - use target quality and quantity
        quality_result = calculate_quality_weights(recipe.level, total_qo)
        target_percentage = quality_result['percentages'][target_quality]
        target_weight = quality_result['weights'][target_quality]
        total_weight = quality_result['total_weight']
        
        # Target crafts: ceiling(total_weight / target_weight) * quantity
        crafts_for_one = math.ceil(total_weight / target_weight) if target_weight > 0 else float('inf')
        target_crafts = crafts_for_one * target_quantity
        
        # Calculate materials needed
        materials_needed = target_crafts / crafts_per_material if crafts_per_material > 0 else 0
        
        # Calculate expected items from material budget (if provided)
        if material_budget is not None:
            max_crafts = material_budget * crafts_per_material
            # For quality items, this is just informational
            expected_items_from_budget = max_crafts  # Total crafts possible
        else:
            expected_items_from_budget = None
    else:
        # Simple item
        if material_budget is not None:
            # Material budget mode: calculate max items from materials
            target_crafts = material_budget * crafts_per_material
            materials_needed = material_budget
            expected_items_from_budget = target_crafts  # Each craft = 1 item
        else:
            # Target quantity mode: calculate materials needed
            target_crafts = target_quantity
            materials_needed = target_crafts / crafts_per_material if crafts_per_material > 0 else 0
            expected_items_from_budget = None
    
    # Total steps for target
    steps_for_target = steps_per_reward_roll * target_crafts
    
    # Total XP gained using XP/step formula
    # xp_per_step = ((base_xp * (1 + xp_pct)) + xp_add) * (actions_per_completion) / current_steps
    total_bonus_xp_percent = gear_stats.get('bonus_xp_percent', 0.0) + service_stats.get('bonus_xp_percent', 0.0) + collectible_stats.get('bonus_xp_percent', 0.0) + consumable_stats.get('bonus_xp_percent', 0.0)
    total_bonus_xp_add = gear_stats.get('bonus_xp_add', 0.0) + service_stats.get('bonus_xp_add', 0.0) + collectible_stats.get('bonus_xp_add', 0.0) + consumable_stats.get('bonus_xp_add', 0.0)
    xp_per_step = ((recipe.base_xp * (1 + total_bonus_xp_percent)) + total_bonus_xp_add) * actions_per_completion / current_steps
    total_xp_gained = xp_per_step * steps_for_target
    
    # Calculate level after gaining XP
    try:
        character = get_character()
        # Use lowercase skill name to match character export format
        current_skill_xp = character.skills.get(recipe.skill.lower(), 0)
        final_skill_xp = current_skill_xp + total_xp_gained
        final_level = xp_to_level(final_skill_xp)
    except:
        current_skill_xp = None
        final_skill_xp = None
        final_level = None
    
    # Normal XP per step (actual rate with all bonuses)
    normal_xp_per_step = total_xp_gained / steps_for_target if steps_for_target > 0 else 0
    
    # Calculate total materials for recipe (sum quantities from selected materials)
    materials_with_objects = get_recipe_materials_with_objects(recipe, prefer_cheapest=True)
    total_base_materials = sum(qty for qty, _, _ in materials_with_objects)
    
    # Calculate material costs
    material_cost_per_craft = calculate_material_cost(recipe, prefer_cheapest=True)
    
    # Calculate cost for perfect item
    material_cost_for_perfect = None
    if material_cost_per_craft is not None:
        material_cost_for_perfect = material_cost_per_craft * target_crafts
    
    return {
        'recipe': recipe.name,
        'recipe_obj': recipe,  # Add recipe object for material alternatives
        'skill': recipe.skill,
        'level_required': recipe.level,
        'skill_level': skill_level,
        'service': service.name,
        'location': location or 'Global',
        
        # Base stats
        'base_steps': recipe.base_steps,
        'base_xp': recipe.base_xp,
        'max_efficiency': recipe.max_efficiency,
        
        # Gear stats (convert from decimal to percentage for display)
        'gear_we': gear_stats['we'] * 100,
        'gear_dr': gear_stats['dr'] * 100,
        'gear_da': gear_stats['da'] * 100,
        'gear_nmc': gear_stats['nmc'] * 100,
        'gear_qo': gear_stats['qo'],
        'gear_flat': gear_stats.get('flat', 0),
        'gear_pct': gear_stats.get('pct', 0.0) * 100,
        
        # Service stats (convert from decimal to percentage for display)
        'service_we': service_stats['we'] * 100,
        'service_dr': service_stats['dr'] * 100,
        'service_da': service_stats['da'] * 100,
        'service_nmc': service_stats['nmc'] * 100,
        'service_qo': service_stats['qo'],
        
        # Collectible stats (convert from decimal to percentage for display)
        'collectible_we': collectible_stats['we'] * 100,
        'collectible_dr': collectible_stats['dr'] * 100,
        'collectible_nmc': collectible_stats['nmc'] * 100,
        'collectible_qo': collectible_stats['qo'],
        
        # Consumable stats (convert from decimal to percentage for display)
        'consumable_we': consumable_stats['we'] * 100,
        'consumable_dr': consumable_stats['dr'] * 100,
        'consumable_da': consumable_stats['da'] * 100,
        'consumable_nmc': consumable_stats['nmc'] * 100,
        'consumable_qo': consumable_stats['qo'],
        'consumable_name': consumable.name if consumable else None,
        'consumable_duration': consumable.duration if consumable else None,
        
        # Level bonuses
        'level_bonus_we': level_bonus_we,
        'level_bonus_qo': level_bonus_qo,
        
        # Total stats (convert from decimal to percentage for display)
        'total_we': total_we * 100,
        'total_dr': total_dr * 100,
        'total_da': total_da * 100,
        'total_nmc': total_nmc * 100,
        'total_qo': total_qo,
        
        # Calculated values
        'current_gear_efficiency': current_gear_efficiency * 100,
        'total_efficiency': total_efficiency * 100,
        'current_steps': current_steps,
        'actions_per_completion': actions_per_completion,
        'reward_rolls_per_completion': reward_rolls_per_completion,
        'steps_per_action': steps_per_action,
        'steps_per_reward_roll': steps_per_reward_roll,
        'crafts_per_material': crafts_per_material,
        'normal_xp_per_step': normal_xp_per_step,
        
        # Materials
        'is_quality_item': is_quality,
        'target_quality': target_quality if is_quality else None,
        'target_quantity': target_quantity,
        'material_budget': material_budget,
        'target_crafts': target_crafts,
        'materials_needed': materials_needed,
        'expected_items_from_budget': expected_items_from_budget,
        'steps_for_target': steps_for_target,
        'total_xp_gained': total_xp_gained,
        'current_skill_xp': current_skill_xp,
        'final_skill_xp': final_skill_xp,
        'final_level': final_level,
        
        # Materials list
        'materials': recipe.materials,
        'materials_with_objects': materials_with_objects,
        'material_cost_per_craft': material_cost_per_craft,
        'material_cost_for_target': material_cost_for_perfect,
        
        # Item breakdown
        'item_breakdown': item_breakdown
    }

def print_craft_stats(stats, show_item_breakdown=True):
    """Pretty print crafting stats."""
    if 'error' in stats:
        print(f"Error: {stats['error']}")
        return
    
    print(f"\n{'='*60}")
    print(f"CRAFT COMPARISON: {stats['recipe']}")
    print(f"{'='*60}")
    print(f"Skill: {stats['skill']} (Level {stats['skill_level']}, Required: {stats['level_required']})")
    print(f"Service: {stats['service']}")
    print(f"Location: {stats['location']}")
    print()
    
    print(f"BASE STATS:")
    print(f"  Base Steps: {format_number(stats['base_steps'], 0)}")
    print(f"  Base XP: {format_number(stats['base_xp'])}")
    print(f"  Max Efficiency: {format_number(stats['max_efficiency']*100)}%")
    print()
    
    # Show per-item breakdown if requested
    if show_item_breakdown and 'item_breakdown' in stats:
        print(f"ITEM BREAKDOWN:")
        for item_name, item_stats in stats['item_breakdown']:
            if any(v != 0 for v in item_stats.values()):
                print(f"  {item_name}:")
                if item_stats.get('work_efficiency', 0) != 0:
                    print(f"    WE: {format_number(item_stats['work_efficiency'] * 100, 3)}%")
                if item_stats.get('double_rewards', 0) != 0:
                    print(f"    DR: {format_number(item_stats['double_rewards'] * 100, 3)}%")
                if item_stats.get('double_action', 0) != 0:
                    print(f"    DA: {format_number(item_stats['double_action'] * 100, 3)}%")
                if item_stats.get('no_materials_consumed', 0) != 0:
                    print(f"    NMC: {format_number(item_stats['no_materials_consumed'] * 100, 3)}%")
                if item_stats.get('quality_outcome', 0) != 0:
                    print(f"    QO: {format_number(item_stats['quality_outcome'], 0)}")
        print()
    
    # Show stats grouped by type if requested
    if SHOW_ALL_ITEM_STATS and 'item_breakdown' in stats:
        print(f"STATS BY TYPE (Item-by-Item):")
        print(f"="*60)
        
        # Collect all stats and their contributors
        stat_contributors = {}
        for item_name, item_stats in stats['item_breakdown']:
            for stat_name, stat_value in item_stats.items():
                if stat_value != 0:
                    if stat_name not in stat_contributors:
                        stat_contributors[stat_name] = []
                    stat_contributors[stat_name].append((item_name, stat_value))
        
        # Display grouped by stat
        for stat_name in sorted(stat_contributors.keys()):
            contributors = stat_contributors[stat_name]
            total = sum(v for _, v in contributors)
            print(f"\n{stat_name.upper()}: {total:.3f}")
            print(f"  Contributors:")
            for item_name, value in contributors:
                print(f"    {item_name:40} {value:+.3f}")
        print()
    
    print(f"GEAR BONUSES:")
    print(f"  Work Efficiency: {format_number(stats['gear_we'], 3)}%")
    print(f"  Double Rewards: {format_number(stats['gear_dr'], 3)}%")
    print(f"  Double Action: {format_number(stats['gear_da'], 3)}%")
    print(f"  No Materials Consumed: {format_number(stats['gear_nmc'], 3)}%")
    print(f"  Quality Outcome: {format_number(stats['gear_qo'], 0)}")
    if stats['gear_flat'] != 0:
        print(f"  Flat Steps: {'+' if stats['gear_flat'] > 0 else ''}{format_number(stats['gear_flat'], 0)}")
    if stats['gear_pct'] != 0:
        print(f"  Percentage Steps: {'+' if stats['gear_pct'] > 0 else ''}{format_number(stats['gear_pct'], 3)}%")
    print()
    
    print(f"SERVICE BONUSES:")
    print(f"  Work Efficiency: {format_number(stats['service_we'], 3)}%")
    print(f"  Double Rewards: {format_number(stats['service_dr'], 3)}%")
    print(f"  Double Action: {format_number(stats['service_da'], 3)}%")
    print(f"  No Materials Consumed: {format_number(stats['service_nmc'], 3)}%")
    print(f"  Quality Outcome: {format_number(stats['service_qo'], 0)}")
    print()
    
    print(f"COLLECTIBLE BONUSES:")
    print(f"  Work Efficiency: {format_number(stats['collectible_we'], 3)}%")
    print(f"  Double Rewards: {format_number(stats['collectible_dr'], 3)}%")
    print(f"  No Materials Consumed: {format_number(stats['collectible_nmc'], 3)}%")
    print(f"  Quality Outcome: {format_number(stats['collectible_qo'], 0)}")
    print()
    
    if stats['consumable_name']:
        consumables_needed = math.ceil(stats['steps_for_target'] / stats['consumable_duration']) if stats['consumable_duration'] else 0
        print(f"CONSUMABLE BONUSES ({stats['consumable_name']}, {format_number(stats['consumable_duration'], 0)} steps):")
        print(f"  Consumables Needed: {format_number(consumables_needed, 0)}")
        print(f"  Work Efficiency: {format_number(stats['consumable_we'], 3)}%")
        print(f"  Double Rewards: {format_number(stats['consumable_dr'], 3)}%")
        print(f"  Double Action: {format_number(stats['consumable_da'], 3)}%")
        print(f"  No Materials Consumed: {format_number(stats['consumable_nmc'], 3)}%")
        print(f"  Quality Outcome: {format_number(stats['consumable_qo'], 0)}")
        print()
    
    print(f"LEVEL BONUSES:")
    print(f"  Work Efficiency: {format_number(stats['level_bonus_we'], 3)}% (capped at recipe level)")
    print(f"  Quality Outcome: {format_number(stats['level_bonus_qo'], 0)} (no cap)")
    print()
    
    print(f"TOTAL STATS:")
    print(f"  Work Efficiency: {format_number(stats['total_we'], 3)}%")
    print(f"  Double Rewards: {format_number(stats['total_dr'], 3)}%")
    print(f"  Double Action: {format_number(stats['total_da'], 3)}%")
    print(f"  No Materials Consumed: {format_number(stats['total_nmc'], 3)}%")
    print(f"  Quality Outcome: {format_number(stats['total_qo'], 0)}")
    print()
    
    print(f"EFFICIENCY:")
    print(f"  Current Gear Efficiency: {format_number(stats['current_gear_efficiency'], 3)}%")
    print(f"  Total Efficiency: {format_number(stats['total_efficiency'], 3)}%")
    print(f"  Current Steps: {format_number(stats['current_steps'], 0)}")
    print(f"  Actions per Completion: {format_number(stats['actions_per_completion'], 4)}")
    print(f"  Reward Rolls per Completion: {format_number(stats['reward_rolls_per_completion'], 4)}")
    print(f"  Steps per Action: {format_number(stats['steps_per_action'], 2)}")
    print(f"  Steps per Reward Roll: {format_number(stats['steps_per_reward_roll'], 2)}")
    print(f"  Normal XP/Step: {format_number(stats['normal_xp_per_step'], 3)}")
    print()
    
    print(f"BASE MATERIALS (per craft):")
    if stats.get('materials_with_objects'):
        for qty, material_name, material_obj in stats['materials_with_objects']:
            status = "✓" if material_obj else "✗"
            print(f"  {status} {qty}x {material_name}")
    else:
        print(f"  (No materials data available)")
    print()
    
    print(f"MATERIALS CALCULATION:")
    print(f"  Crafts per Material: {format_number(stats['crafts_per_material'], 4)}")
    print()
    
    # Display target based on item type and mode
    if stats['material_budget'] is not None:
        # Material budget mode
        print(f"FROM {format_number(stats['material_budget'])} MATERIALS:")
        print(f"  Expected Crafts: {format_number(stats['target_crafts'], 0)}")
        if stats['is_quality_item']:
            print(f"  Expected Items: {format_number(stats['expected_items_from_budget'], 0)} total crafts (quality distribution varies)")
        else:
            print(f"  Expected Items: {format_number(stats['expected_items_from_budget'], 0)}")
        print(f"  Total Steps: {format_number(stats['steps_for_target'], 0)}")
        print(f"  Total XP: {stats['total_xp_gained']:.0f}")
        if stats.get('final_level') is not None:
            print(f"  Level: {stats['skill_level']} → {stats['final_level']}")
    else:
        # Target quantity mode
        if stats['is_quality_item']:
            target_label = f"{stats['target_quantity']}x {stats['target_quality'].upper()}" if stats['target_quantity'] > 1 else f"1 {stats['target_quality'].upper()} ITEM"
        else:
            target_label = f"{stats['target_quantity']} ITEMS"
        
        print(f"FOR {target_label}:")
        print(f"  Target Crafts: {format_number(stats['target_crafts'], 0)}")
        print(f"  Materials Needed: {format_number(stats['materials_needed'])}")
        print(f"  Total Steps: {format_number(stats['steps_for_target'], 0)}")
        print(f"  Total XP: {format_number(stats['total_xp_gained'], 0)}")
        if stats.get('final_level') is not None:
            print(f"  Level: {stats['skill_level']} → {stats['final_level']}")
    
    # Show level progression if iterative calculation was used
    if stats.get('used_iterative') and stats.get('level_progression'):
        print()
        print(f"LEVEL PROGRESSION:")
        for i, (level, xp, crafts, materials, steps) in enumerate(stats['level_progression']):
            # Calculate XP until next level
            next_level_xp = level_to_xp(level + 1)
            xp_to_next = next_level_xp - xp
            
            if crafts == 0:
                print(f"  Level {level}: Starting (XP: {format_number(xp, 0)}, {format_number(xp_to_next, 0)} to next)")
            else:
                # Check if this is the last entry (final level)
                is_final = (i == len(stats['level_progression']) - 1)
                if is_final:
                    print(f"  Level {level}: After {format_number(crafts, 0)} crafts ({format_number(materials)} materials, {format_number(steps, 0)} steps, XP: {format_number(xp, 0)}, {format_number(xp_to_next, 0)} to next)")
                else:
                    print(f"  Level {level}: After {format_number(crafts, 0)} crafts ({format_number(materials)} materials, {format_number(steps, 0)} steps, XP: {format_number(xp, 0)})")
    
    print()
    
    # Calculate and display total materials needed per material type
    if stats.get('materials'):
        from util.recipe_materials import get_all_material_alternatives
        
        materials_multiplier = stats['materials_needed']
        all_alternatives = get_all_material_alternatives(stats['recipe_obj'])
        
        if len(all_alternatives) > 1:
            # Multiple alternatives - show all with OR
            print(f"  Materials Breakdown ({format_number(materials_multiplier)}x base materials):")
            for alt_idx, alternative in enumerate(all_alternatives):
                if alt_idx > 0:
                    print(f"    --- OR ---")
                
                for qty, material_name, material_obj, cost in alternative:
                    total_qty = qty * materials_multiplier
                    print(f"    {format_number(total_qty)}x {material_name}")
        else:
            # Single alternative - show normally
            print(f"  Materials Breakdown ({format_number(materials_multiplier)}x base materials):")
            for qty, material_name, material_obj in stats['materials_with_objects']:
                total_qty = qty * materials_multiplier
                print(f"    {format_number(total_qty)}x {material_name}")
    
    print(f"{'='*60}")

if __name__ == '__main__':
    print("Craft Comparison Tool")
    print("=" * 60)
    
    # Check if configuration is set
    if not GEARSET_EXPORT:
        print("\nPlease configure the tool by editing the variables at the top of this file:")
        print("  - RECIPE: Recipe object (e.g., Recipes.IRON_SICKLE)")
        print("  - SERVICE: Service object (e.g., Services.BASIC_FORGE_KALLAHEIM)")
        print("  - GEARSET_EXPORT: Your gearset export string")
        print("\nCharacter export is loaded from my_config.py")
        print("Edit CHARACTER_EXPORT in my_config.py to set your character data")
        print("\nExample:")
        print('  from util.recipes import Recipes')
        print('  from util.services import Services')
        print('  RECIPE = Recipes.IRON_SICKLE')
        print('  SERVICE = Services.BASIC_FORGE_KALLAHEIM')
        print('  GEARSET_EXPORT = "H4sIAAAA..."')
        print("\nOr call calculate_crafting_stats() directly:")
        print('  stats = calculate_crafting_stats(Recipes.IRON_SICKLE, Services.BASIC_FORGE_KALLAHEIM, gearset_export)')
        print('  print_craft_stats(stats)')
    else:
        # Run with configured values
        if USE_ITERATIVE_CALCULATION:
            stats = calculate_crafting_stats_iterative(
                RECIPE,
                SERVICE,
                GEARSET_EXPORT,
                CONSUMABLE,
                TARGET_QUALITY,
                TARGET_QUALITY_QUANTITY if is_quality_item(RECIPE.name) else TARGET_QUANTITY,
                MATERIAL_BUDGET
            )
        else:
            stats = calculate_crafting_stats(
                RECIPE,
                SERVICE,
                GEARSET_EXPORT,
                CONSUMABLE,
                TARGET_QUALITY,
                TARGET_QUALITY_QUANTITY if is_quality_item(RECIPE.name) else TARGET_QUANTITY,
                MATERIAL_BUDGET
            )
        print_craft_stats(stats)
