#!/usr/bin/env python3
"""
Miscellaneous utility functions.
"""


def format_number(value: float, max_decimals: int = 3) -> str:
    """
    Format a number to show decimals only if they exist.
    
    Args:
        value: Number to format
        max_decimals: Maximum decimal places to show
        
    Returns:
        Formatted string (e.g., "50" or "50.5")
    
    Examples:
        >>> format_number(50.0)
        '50'
        >>> format_number(50.5)
        '50.5'
        >>> format_number(50.123, 2)
        '50.12'
        >>> format_number(50.100, 2)
        '50.1'
    """
    if max_decimals == 0:
        # For 0 decimals, just round to int
        return str(int(round(value)))
    elif value == int(value):
        return str(int(value))
    else:
        return f"{value:.{max_decimals}f}".rstrip('0').rstrip('.')



def name_to_enum(name):
    """Convert a name to Python enum constant format."""
    # Remove special characters and convert to uppercase with underscores
    import re
    # Replace special characters with spaces
    name = re.sub(r'[^\w\s-]', '', name)
    # Replace spaces and hyphens with underscores
    name = name.replace(' ', '_').replace('-', '_')
    # Convert to uppercase
    name = name.upper()
    # Remove consecutive underscores
    name = re.sub(r'_+', '_', name)
    # Remove leading/trailing underscores
    name = name.strip('_')
    # If starts with digit, prefix with underscore
    if name and name[0].isdigit():
        name = '_' + name
    return name


def build_all_item_lookups():
    """
    Build lookup dictionaries for all item types defined in autogenerated modules.
    
    Returns:
        Dict with structure: {
            'Item': {name.lower(): 'ENUM_NAME'},
            'Material': {name.lower(): 'ENUM_NAME'},
            ...
        }
    """
    lookups = {}
    
    import sys
    
    # Force-load walkscape_constants first to get Item
    # This avoids circular import issues
    try:
        from util.walkscape_constants import Item
        # Build Item lookup
        lookup = {}
        for attr_name in dir(Item):
            if not attr_name.startswith('__'):
                try:
                    obj = getattr(Item, attr_name)
                    if hasattr(obj, 'name'):
                        lookup[obj.name.lower()] = attr_name
                except:
                    pass
        if lookup:
            lookups['Item'] = lookup
    except Exception as e:
        # Can't load Item - skip
        pass
    
    # Define all other item types to check
    item_imports = [
        ('Material', 'util.autogenerated.materials', 'Material'),
        ('Consumable', 'util.autogenerated.consumables', 'Consumable'),
        ('Collectible', 'util.autogenerated.collectibles', 'Collectible'),
        ('Location', 'util.autogenerated.locations', 'Location'),
        ('Activity', 'util.autogenerated.activities', 'Activity'),
        ('Recipe', 'util.autogenerated.recipes', 'Recipe'),
        ('Service', 'util.autogenerated.services', 'Service'),
        ('Container', 'util.autogenerated.containers', 'Container'),
        ('Pet', 'util.autogenerated.pets', 'Pet'),
        ('Egg', 'util.autogenerated.pets', 'Egg'),
        ('Currency', 'util.autogenerated.currency', 'Currency'),
    ]
    
    for type_name, module_name, class_name in item_imports:
        try:
            # Check if module is already imported
            if module_name in sys.modules:
                module = sys.modules[module_name]
                type_class = getattr(module, class_name, None)
                if not type_class:
                    continue
            else:
                # Try to import the module
                try:
                    module = __import__(module_name, fromlist=[class_name])
                    type_class = getattr(module, class_name)
                except ImportError:
                    continue
            
            # Build lookup dict
            lookup = {}
            for attr_name in dir(type_class):
                if not attr_name.startswith('__'):
                    try:
                        obj = getattr(type_class, attr_name)
                        if hasattr(obj, 'name'):
                            lookup[obj.name.lower()] = attr_name
                    except:
                        pass
            
            if lookup:
                lookups[type_name] = lookup
        except Exception:
            pass
    
    return lookups


def resolve_item_reference(name, lookups=None):
    """
    Resolve an item name to its module reference.
    
    Args:
        name: Item name to resolve
        lookups: Pre-built lookup dicts from build_all_item_lookups(), or None to build fresh
    
    Returns:
        String like "Material.FISHBONE" or None if not found
    """
    if lookups is None:
        lookups = build_all_item_lookups()
    
    if not lookups:
        return None
    
    # Try different name variations
    name_lower = name.lower()
    variations = [
        name,
        name.replace("'", ""),  # Remove straight apostrophes
        name.replace("'", ""),  # Remove curly apostrophes
    ]
    
    # Try each type in order (Material, Item, Consumable, etc.)
    for type_name, type_lookup in lookups.items():
        for name_variant in variations:
            if name_variant.lower() in type_lookup:
                enum_name = type_lookup[name_variant.lower()]
                return f"{type_name}.{enum_name}"
    
    return None
