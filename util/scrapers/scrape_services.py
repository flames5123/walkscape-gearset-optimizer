#!/usr/bin/env python3
"""
Scrape services from the Walkscape wiki Services page.
Generates services.py with all service data.
"""

from bs4 import BeautifulSoup
from scraper_utils import *
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))
from autogenerated.locations import Location
import re

# Configuration
RESCRAPE = False
SERVICES_URL = 'https://wiki.walkscape.app/wiki/Services'
CACHE_FILE = get_cache_file('services_cache.html')

# Create validator instance
validator = ScraperValidator()

def clean_text(text):
    """Clean up text by removing extra whitespace."""
    return ' '.join(text.split()).strip()

def normalize_stat_name(stat_text: str) -> str:
    """Normalize stat names to match equipment.py conventions."""
    stat_lower = stat_text.lower().strip()
    
    stat_map = {
        'work efficiency': 'work_efficiency',
        'double rewards': 'double_rewards',
        'double action': 'double_action',
        'no materials consumed': 'no_materials_consumed',
        'quality outcome': 'quality_outcome',
        'bonus experience': 'bonus_xp_percent',
    }
    
    return stat_map.get(stat_lower, stat_lower.replace(' ', '_'))

def extract_attributes(td):
    """
    Extract attribute bonuses with reputation thresholds.
    Returns: (stats, reputation_stats)
    - stats: {skill: {location: {stat: value}}} for non-reputation bonuses
    - reputation_stats: {faction: {threshold: {skill: {location: {stat: value}}}}}
    """
    stats = {}
    reputation_stats = {}
    text = td.get_text()
    
    if 'None' in text or not text.strip():
        return stats, reputation_stats
    
    # Find all stat patterns in the text (multiple stats can be on same line)
    # Pattern 1: Global +X% Stat Name (for global bonuses)
    # Pattern 2: +/-X% Stat Name While doing Skill (for skill-specific bonuses)
    
    # Try global pattern first - capture everything including reputation requirement
    # Note: There can be multiple spaces between elements, and stat names can have multiple words
    # Pattern handles: "Global +1% Double rewards Have [5] Halfling Rebels faction reputation."
    global_pattern = r'Global\s+([+-]?\d+(?:\.\d+)?)\s*(%?)\s+(.+?)\s+[Hh]ave\s+\[(\d+)\]\s+(.+?)\s+[Ff]action\s+[Rr]eputation'
    skill_pattern = r'([+-]?\d+(?:\.\d+)?)\s*(%?)\s+([A-Za-z\s]+?)\s+While doing\s+([A-Za-z]+)'
    
    # Process global bonuses with reputation requirements
    for match in re.finditer(global_pattern, text, re.IGNORECASE):
        value_str = match.group(1)
        has_percent = match.group(2) == '%'
        stat_name_raw = match.group(3).strip()  # Strip extra whitespace
        threshold = int(match.group(4))
        faction = match.group(5).strip().lower().replace(' ', '_')
        skill = 'global'  # Global bonuses apply to all skills
        
        # Normalize stat name using shared function
        stat_name = normalize_stat_name(stat_name_raw)
        if not stat_name:
            validator.add_unrecognized_stat('Service', match.group(0))
            continue
        
        # Build value string with % if present for parse_stat_value
        value_with_percent = value_str
        if has_percent:
            value_with_percent += '%'
        
        # Use shared function to parse value (handles dual-format stats)
        final_stat_name, final_value = parse_stat_value(value_with_percent, stat_name)
        
        # All service bonuses are global location
        location = 'global'
        
        # Reputation-gated bonus
        if faction not in reputation_stats:
            reputation_stats[faction] = {}
        if threshold not in reputation_stats[faction]:
            reputation_stats[faction][threshold] = {}
        if skill not in reputation_stats[faction][threshold]:
            reputation_stats[faction][threshold][skill] = {}
        if location not in reputation_stats[faction][threshold][skill]:
            reputation_stats[faction][threshold][skill][location] = {}
        
        reputation_stats[faction][threshold][skill][location][final_stat_name] = final_value
    
    # Process skill-specific bonuses
    for match in re.finditer(skill_pattern, text, re.IGNORECASE):
        value_str = match.group(1)
        has_percent = match.group(2) == '%'
        stat_name_raw = clean_text(match.group(3))
        skill = match.group(4).lower()
        
        # Normalize stat name using shared function
        stat_name = normalize_stat_name(stat_name_raw)
        if not stat_name:
            validator.add_unrecognized_stat('Service', match.group(0))
            continue
        
        # Build value string with % if present for parse_stat_value
        value_with_percent = value_str
        if has_percent:
            value_with_percent += '%'
        
        # Use shared function to parse value (handles dual-format stats)
        final_stat_name, final_value = parse_stat_value(value_with_percent, stat_name)
        
        # All service bonuses are global location
        location = 'global'
        
        # Check if this stat has a reputation requirement
        # Look for "have X Faction Reputation" after this stat (within 100 chars)
        remaining_text = text[match.end():match.end()+100]
        rep_match = re.search(r'have (\d+)\s+([A-Za-z\s]+?)\s+Faction Reputation', remaining_text, re.IGNORECASE)
        
        if rep_match:
            # Reputation-gated bonus
            threshold = int(rep_match.group(1))
            faction = rep_match.group(2).strip().lower().replace(' ', '_')
            
            if faction not in reputation_stats:
                reputation_stats[faction] = {}
            if threshold not in reputation_stats[faction]:
                reputation_stats[faction][threshold] = {}
            if skill not in reputation_stats[faction][threshold]:
                reputation_stats[faction][threshold][skill] = {}
            if location not in reputation_stats[faction][threshold][skill]:
                reputation_stats[faction][threshold][skill][location] = {}
            
            reputation_stats[faction][threshold][skill][location][final_stat_name] = final_value
        else:
            # Regular bonus (no reputation requirement)
            if skill not in stats:
                stats[skill] = {}
            if location not in stats[skill]:
                stats[skill][location] = {}
            stats[skill][location][final_stat_name] = final_value
    
    return stats, reputation_stats

def extract_requirement(td):
    """
    Extract and parse requirements into structured format with keyword_counts.
    Returns: Dict with keyword_counts, skill, reputation, access (like activities)
    """
    text = clean_text(td.get_text())
    if text.lower() == 'none' or not text:
        return {'keyword_counts': {}, 'skill': {}, 'reputation': {}, 'access': []}
    
    requirements = {'keyword_counts': {}, 'skill': {}, 'reputation': {}, 'access': []}
    
    # Check for diving gear requirement - multiple patterns
    if 'diving gear' in text.lower():
        # Pattern 1: "Have X of Diving Gear"
        match = re.search(r'Have (\d+) of Diving Gear', text, re.IGNORECASE)
        if not match:
            # Pattern 2: "Requires [X] unique Diving gear"
            match = re.search(r'\[(\d+)\].*?[Dd]iving [Gg]ear', text)
        if match:
            # Check if it's advanced diving gear
            if 'advanced' in text.lower():
                requirements['keyword_counts']['advanced diving gear'] = int(match.group(1))
            else:
                requirements['keyword_counts']['diving gear'] = int(match.group(1))
    
    # Check for reputation requirement - handle both formats
    # Format 1: "Have X Faction Reputation"
    rep_match = re.search(r'Have (\d+)\s+([A-Za-z\s]+?)\s+Faction Reputation', text, re.IGNORECASE)
    if not rep_match:
        # Format 2: "Have [X] Faction faction reputation"
        rep_match = re.search(r'[Hh]ave\s+\[(\d+)\]\s+(.+?)\s+[Ff]action\s+[Rr]eputation', text)
    
    if rep_match:
        faction = rep_match.group(2).strip().lower().replace(' ', '_')
        requirements['reputation'][faction] = int(rep_match.group(1))
    
    # Check for skill requirement (but not if it's part of diving gear or access text)
    # Format: "At least Carpentry lvl. 20" or "Carpentry 20"
    if 'diving gear' not in text.lower() and 'access' not in text.lower():
        # Try pattern with "lvl." first
        skill_match = re.search(r'([A-Za-z]+)\s+lvl?\.\s*(\d+)', text, re.IGNORECASE)
        if not skill_match:
            # Try simple pattern
            skill_match = re.search(r'([A-Za-z]+)\s+(\d+)', text)
        
        if skill_match and not rep_match:  # Don't match numbers from reputation
            skill_name = skill_match.group(1)
            requirements['skill'][skill_name] = int(skill_match.group(2))
    
    # Check for access requirement (like "Syrenthia Access")
    if 'access' in text.lower():
        access_match = re.search(r'([A-Za-z]+)\s+Access', text, re.IGNORECASE)
        if access_match:
            requirements['access'].append(access_match.group(1).lower())
    
    return requirements

def parse_services():
    """Parse all services from the cached HTML file."""
    # Download using standard function
    html = download_page(SERVICES_URL, CACHE_FILE, rescrape=RESCRAPE)
    if not html:
        print("Failed to download Services page")
        return []
    
    soup = BeautifulSoup(html, 'html.parser')
    
    services = []
    seen_services = set()  # Track (name, location) to avoid duplicates
    current_category = None
    current_tier = None
    
    # Find all service tables - only in the main content area
    content_div = soup.find('div', class_='mw-parser-output')
    if not content_div:
        print("Could not find main content div")
        return []
    
    # Find all service tables
    for heading in content_div.find_all(['h2', 'h3']):
        heading_text = clean_text(heading.get_text())
        
        # Skip "Contents" and numbers
        heading_text = re.sub(r'^\d+(\.\d+)?\s*', '', heading_text)
        
        if not heading_text or heading_text == 'Contents' or heading_text == 'Levels':
            continue
        
        # Skip wardrobes - they're not crafting services
        if 'wardrobe' in heading_text.lower():
            current_category = None  # Reset category to skip subsequent tables
            continue
        
        # Determine if this is a category (h2) or tier (h3)
        if heading.name == 'h2':
            # Category like "Carpentry Services", "Cooking Services"
            current_category = heading_text.replace(' Services', '')
        elif heading.name == 'h3':
            # Tier like "Basic Sawmills", "Advanced Sawmills"
            # Remove plural to get "Basic Sawmill", "Advanced Sawmill"
            if heading_text.endswith('ches'):
                current_tier = heading_text[:-2]  # "Benches" -> "Bench"
            elif heading_text.endswith('s') and not heading_text.endswith('ss'):
                current_tier = heading_text[:-1]  # "Sawmills" -> "Sawmill"
            else:
                current_tier = heading_text
        
        # Skip if we're in a wardrobe section (category was reset to None)
        if current_category is None:
            continue
        
        # Don't process tables here - we'll find them separately
        continue
    
    # Now find all service tables and determine their tier from preceding headings
    for table in content_div.find_all('table', class_='wikitable'):
        # Check if this is a service table
        headers = table.find_all('th')
        header_text = ' '.join([clean_text(h.get_text()) for h in headers])
        
        if 'Name' not in header_text or 'Location' not in header_text:
            continue
        
        # Find the tier heading (h3) before this table
        tier_heading = table.find_previous('h3')
        if tier_heading:
            tier_text = clean_text(tier_heading.get_text())
            tier_text = re.sub(r'^\d+(\.\d+)?\s*', '', tier_text)
            # Extract full service type like "Basic Sawmills" -> "Basic Sawmill"
            # Remove plural
            if tier_text.endswith('ches'):
                current_tier = tier_text[:-2]  # "Benches" -> "Bench"
            elif tier_text.endswith('s') and not tier_text.endswith('ss'):
                current_tier = tier_text[:-1]  # "Sawmills" -> "Sawmill"
            else:
                current_tier = tier_text
        
        # Find the category heading (h2) before this table
        category_heading = table.find_previous('h2')
        if category_heading:
            category_text = clean_text(category_heading.get_text())
            category_text = re.sub(r'^\d+(\.\d+)?\s*', '', category_text)
            
            # Skip wardrobes
            if 'wardrobe' in category_text.lower():
                continue
            
            current_category = category_text.replace(' Services', '')
        
        # Skip if no valid category
        if not current_category:
            continue
        
        # Parse each service row
        for row in table.find_all('tr')[1:]:  # Skip header row
            cells = row.find_all('td')
            if len(cells) < 6:
                continue
            
            # Extract data from cells (NEW STRUCTURE after wiki update)
            # 0: Icon, 1: Name (with tier in parentheses), 2: Service Tier, 3: Locations, 4: Attributes, 5: Requirements
            
            # Get full name with tier
            full_name = clean_text(cells[1].get_text())
            
            # Extract base name and tier from name
            # Format: "Service Name (Basic)" or "Service Name (Advanced)"
            name_match = re.match(r'(.+?)\s*\((Basic|Advanced)\)', full_name)
            if name_match:
                service_name = name_match.group(1).strip()
                tier_from_name = name_match.group(2)
            else:
                service_name = full_name
                tier_from_name = None
            
            # Get tier from column 2
            tier = clean_text(cells[2].get_text())
            
            # Get location(s) from column 3
            # Locations are separated by <br> tags, not spaces
            location_cell = cells[3]
            # Use get_text with separator to split by <br>
            location_text = location_cell.get_text(separator='|', strip=True)
            locations = [loc.strip() for loc in location_text.split('|') if loc.strip()]
            
            # Extract attributes from column 4
            attributes = {}
            reputation_stats = {}
            if len(cells) > 4:
                attr4, rep4 = extract_attributes(cells[4])
                if attr4 or rep4:
                    attributes = attr4
                    reputation_stats = rep4
            attributes = {}
            reputation_stats = {}
            if len(cells) > 4:
                attr4, rep4 = extract_attributes(cells[4])
                if attr4 or rep4:
                    attributes = attr4
                    reputation_stats = rep4
            
            # Extract requirements from column 5
            requirement = []
            if len(cells) > 5:
                requirement = extract_requirement(cells[5])
            
            # locations is already a list from the <br> split above
            # Create a service entry for each location
            for loc in locations:
                # Look up Location object
                location_obj = Location.by_name(loc)
                if not location_obj:
                    print(f"  Warning: Location '{loc}' not found in Location class")
                    location_obj = loc  # Fall back to string
                
                # Check for duplicates - keep first occurrence
                service_key = (service_name, loc)
                if service_key in seen_services:
                    print(f"  Skipping duplicate: {service_name} at {loc}")
                    continue
                seen_services.add(service_key)
                
                service = {
                    'name': service_name,
                    'category': current_category,
                    'tier': current_tier,  # Use tier from heading, not from cell
                    'location': location_obj,
                    'location_name': loc,  # Keep string for generation
                    'requirement': requirement,
                    'attributes': attributes,
                    'reputation_stats': reputation_stats
                }
                
                # Validate service attributes
                issues = validator.validate_item_stats(service_name, attributes)
                if issues:
                    validator.add_item_issue(service_name, issues)
                
                services.append(service)
                print(f"  {current_tier} {current_category}: {service_name} at {loc}")
    
    return services

def generate_python_module(services):
    """Generate the services.py module."""
    output_file = get_output_file('services.py')
    
    with open(output_file, 'w', encoding='utf-8') as f:
        write_module_header(f, 'Auto-generated service data from Walkscape wiki.', 'scrape_services.py')
        write_imports(f, [
            'from dataclasses import dataclass',
            'from typing import List, Tuple, Optional',
            '',
            'from util.autogenerated.locations import Location, LocationInfo',
            'from util.walkscape_constants import Skill',
            'from util.stats_mixin import StatsMixin'
        ])
        
        lines = [
        'class ServiceInstance(StatsMixin):',
        '    """Represents a crafting service location."""',
        '    def __init__(self, name: str, category: Skill, tier: str, location: Location, requirements: dict, stats: dict, gated_stats: dict):',
        '        self.name = name',
        '        self.category = category  # Skill object (e.g., Skill.CARPENTRY)',
        '        self.tier = tier',
        '        self.location = location',
        '        self.requirements = requirements',
        '        self._stats = stats  # {skill: {location: {stat: value}}}',
        '        self.gated_stats = gated_stats  # Includes reputation gates',
        '',
        '    def is_valid_for_recipe(self, recipe) -> bool:',
        '        """',
        '        Check if this service can be used for the given recipe.',
        '        Advanced services can craft Basic recipes (backwards compatible).',
        '        ',
        '        Args:',
        '            recipe: Recipe object with .service attribute',
        '        ',
        '        Returns:',
        '            True if service is valid for recipe, False otherwise',
        '        """',
        '        recipe_service = recipe.service.lower()',
        '        ',
        '        # Get service category name',
        '        service_category = self.category.value.lower() if hasattr(self.category, "value") else self.category.lower()',
        '        service_tier = self.tier.lower()',
        '        ',
        '        # Check tier compatibility',
        '        # Advanced can do Basic, but not vice versa',
        '        if "basic" in recipe_service and "advanced" in service_tier:',
        '            return True  # Advanced can do Basic recipes',
        '        elif service_tier in recipe_service:',
        '            return True  # Exact match',
        '        elif service_category in recipe_service:',
        '            return True',
        '        elif "advanced" in recipe_service and "basic" in service_tier:',
        '            return False  # Basic cannot do Advanced recipes',
        '',
        '        return False',
        '',
        '    def is_unlocked(self, character, gearset=None) -> bool:',
        '        """',
        '        Check if service is unlocked for character with optional gearset validation.',
        '        ',
        '        Args:',
        '            character: Character object',
        '            gearset: Optional Gearset object for checking gear requirements',
        '        ',
        '        Returns:',
        '            True if unlocked, False otherwise',
        '        """',
        '        # Check skill requirements',
        '        for skill, required_level in self.requirements.get(\'skill\', {}).items():',
        '            if character.get_skill_level(skill.lower()) < required_level:',
        '                return False',
        '        ',
        '        # Check reputation requirements',
        '        for faction, required_amount in self.requirements.get(\'reputation\', {}).items():',
        '            if character.reputation.get(faction, 0) < required_amount:',
        '                return False',
        '        ',
        '        # Check keyword requirements (needs gearset)',
        '        if gearset:',
        '            keyword_counts = self.requirements.get(\'keyword_counts\', {})',
        '            for keyword, required_count in keyword_counts.items():',
        '                if required_count <= 0:',
        '                    continue',
        '                ',
        '                # Count items with this keyword',
        '                count = sum(',
        '                    1 for slot, item in gearset.get_all_items()',
        '                    if item and hasattr(item, \'keywords\') and',
        '                    any(keyword.lower() == kw.lower() for kw in item.keywords)',
        '                )',
        '                if count < required_count:',
        '                    return False',
        '        ',
        '        return True',
        '',
        # Generate enum-style access with direct instantiation
        'class Service:',
        '    """Enum-style access to all services."""',
        '',
        ]
    
        # Track unique service identifiers (name + location for uniqueness)
        seen = set()
        for service in services:
            # Create unique identifier: NAME_AT_LOCATION
            location_name = service['location_name']
            attr_name = f"{service['name']}_{location_name}".upper().replace(' ', '_').replace('-', '_').replace("'", '')
            
            # Skip duplicates
            if attr_name in seen:
                continue
            seen.add(attr_name)
            
            # Generate Location lookup
            location_attr = location_name.upper().replace(' ', '_').replace("'", '').replace('-', '_')
            
            # Build gated_stats dict
            gated_stats_dict = {}
            if service["reputation_stats"]:
                gated_stats_dict["reputation"] = service["reputation_stats"]
            
            # Direct instantiation
            category_skill = f'Skill.{service["category"].upper()}'
            lines.extend([
            f'    {attr_name} = ServiceInstance(',
            f'        name={repr(service["name"])},',
            f'        category={category_skill},',
            f'        tier={repr(service["tier"])},',
            f'        location=Location.{location_attr},',
            f'        requirements={repr(service["requirement"])},',
            f'        stats={repr(service["attributes"])},',
            f'        gated_stats={repr(gated_stats_dict)}',
            '    )',
            '',
            ])
    
        lines.extend([
        '# Helper dictionaries for lookup',
        'SERVICES_BY_NAME = {}',
        'SERVICES_BY_CATEGORY = {}',
        '',
        'for attr_name in dir(Service):',
        '    if not attr_name.startswith("_"):',
        '        service = getattr(Service, attr_name)',
        '        if isinstance(service, ServiceInstance):',
        '            # Add to ID lookup (use attr_name as unique key)',
        '            service_id = attr_name.lower()',
        '            SERVICES_BY_NAME[service_id] = service',
        '            # Add to category lookup',
        '            key = (service.category, service.tier)',
        '            if key not in SERVICES_BY_CATEGORY:',
        '                SERVICES_BY_CATEGORY[key] = []',
        '            SERVICES_BY_CATEGORY[key].append(service)',
        '',
        ])
    
        # Add helper function

    
        f.write('\n'.join(lines))
    
    print(f"\nâœ“ Generated {output_file} with {len(services)} services")

if __name__ == '__main__':
    services = parse_services()
    print(f"\nFound {len(services)} services")
    generate_python_module(services)
    
    # Report validation issues
    validator.report()
