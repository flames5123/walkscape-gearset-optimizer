#!/usr/bin/env python3
"""
Generate export names from equipment, consumables, and materials modules.
Generates export_names.py with export name to Item/Consumable/Material mappings.

This scraper reads directly from the generated Python modules instead of
scraping the wiki, since those modules already have the canonical item names.
"""

from scraper_utils import *
import sys
import re

# Add parent to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

# Note: We can't import walkscape_constants here because it imports export_names
# which we're regenerating. The equipment module will handle its own imports.

def extract_export_names_from_file(module_path, item_type):
    """Extract export names by parsing the Python file directly (no imports)."""
    print(f"Reading {module_path}...")
    
    if not module_path.exists():
        print(f"WARNING: {module_path} not found")
        return []
    
    export_names = []
    seen_enum_names = set()
    content = module_path.read_text(encoding='utf-8')
    
    # Find all item definitions using regex
    # Pattern: ITEM_NAME = ItemInstance(name="Item Name", ...)
    # or: ITEM_NAME = CraftedItem(name="Item Name", ...)
    # or: ITEM_NAME = AchievementItem(name="Item Name", ...)
    # Match content between quotes (either single or double)
    pattern = r'^\s*([A-Z_][A-Z0-9_]*)\s*=\s*(?:ItemInstance|CraftedItem|AchievementItem|ConsumableItem|MaterialInstance)\(\s*name=["' + "'" + r'](.*?)["' + "'" + r']'
    
    for match in re.finditer(pattern, content, re.MULTILINE):
        enum_name = match.group(1)
        item_name = match.group(2)
        
        # Skip duplicates (can happen with quality variants or other reasons)
        if enum_name in seen_enum_names:
            continue
        seen_enum_names.add(enum_name)
        
        # Include _FINE variants for materials/consumables so they can be looked up directly
        
        # Convert ENUM_NAME to export_name (lowercase)
        # The enum name is the source of truth for the export name
        export_name = enum_name.lower()
        
        export_names.append({
            'export_name': export_name,
            'enum_name': enum_name,
            'item_name': item_name,
            'item_type': item_type
        })
    
    return export_names

def extract_all_export_names():
    """Extract export names from equipment, consumables, and materials files."""
    all_names = []
    
    # Get paths to the generated files
    autogen_dir = Path(__file__).parent.parent / 'autogenerated'
    
    # Extract from equipment
    equipment_path = autogen_dir / 'equipment.py'
    equipment_names = extract_export_names_from_file(equipment_path, 'equipment')
    print(f"  Found {len(equipment_names)} equipment items")
    all_names.extend(equipment_names)
    
    # Extract from consumables
    consumables_path = autogen_dir / 'consumables.py'
    consumables_names = extract_export_names_from_file(consumables_path, 'consumable')
    print(f"  Found {len(consumables_names)} consumables")
    all_names.extend(consumables_names)
    
    # Extract from materials
    materials_path = autogen_dir / 'materials.py'
    materials_names = extract_export_names_from_file(materials_path, 'material')
    print(f"  Found {len(materials_names)} materials")
    all_names.extend(materials_names)
    
    return all_names

def generate_export_names_module(export_names):
    """Generate the export_names.py module."""
    output_file = get_output_file('export_names.py')
    
    print(f"\nGenerating {output_file}...")
    
    # Separate by type
    equipment = [e for e in export_names if e['item_type'] == 'equipment']
    consumables = [e for e in export_names if e['item_type'] == 'consumable']
    materials = [e for e in export_names if e['item_type'] == 'material']
    
    with open(output_file, 'w', encoding='utf-8') as f:
        write_module_header(f, 'Export name to item/consumable/material mapping', 'scrape_export_names.py')
        write_imports(f, ['from typing import Optional, Union, TYPE_CHECKING'])
        
        lines = [
        'if TYPE_CHECKING:',
        '    from util.autogenerated.equipment import Item',
        '    from util.autogenerated.consumables import Consumable',
        '    from util.autogenerated.materials import Material',
        '',
        '',
        # ExportNames class with constants
        'class ExportNames:',
        '    """Mapping from export names to items/consumables/materials"""',
        '    ',
        ]

        # Add all export name constants (deduplicated by constant name)
        seen_constants = set()
        for entry in sorted(export_names, key=lambda x: x['export_name']):
            export_const = entry['export_name'].upper().replace("'", "").replace("-", "_").replace(" ", "_")
            export_value = entry['export_name']
            
            # Skip if we've already added this constant
            if export_const in seen_constants:
                continue
            seen_constants.add(export_const)
            
            lines.append(f'    {export_const} = "{export_value}"')
        
        lines.extend([
        '',
        '',
        # Mapping dictionaries - built lazily to avoid circular import
        '# Export name mappings (built on first access)',
        '_EXPORT_NAME_TO_ITEM = None',
        '_EXPORT_NAME_TO_CONSUMABLE = None',
        '_EXPORT_NAME_TO_MATERIAL = None',
        '_EXPORT_NAME_TO_ANY = None',
        '',
        'def _build_item_mapping():',
        '    """Build the export name to Item mapping."""',
        '    from util.autogenerated.equipment import Item',
        '    return {',
        ])

        # Equipment mapping
        for entry in sorted(equipment, key=lambda x: x['export_name']):
            export_name = entry['export_name']
            enum_name = entry['enum_name']
            lines.append(f'        "{export_name}": Item.{enum_name},')
        
        lines.extend([
        '    }',
        '',
        'def _build_consumable_mapping():',
        '    """Build the export name to Consumable mapping."""',
        '    from util.autogenerated.consumables import Consumable',
        '    return {',
        ])

        # Consumables mapping
        for entry in sorted(consumables, key=lambda x: x['export_name']):
            export_name = entry['export_name']
            enum_name = entry['enum_name']
            lines.append(f'        "{export_name}": Consumable.{enum_name},')
        
        lines.extend([
        '    }',
        '',
        'def _build_material_mapping():',
        '    """Build the export name to Material mapping."""',
        '    from util.autogenerated.materials import Material',
        '    return {',
        ])

        # Materials mapping
        for entry in sorted(materials, key=lambda x: x['export_name']):
            export_name = entry['export_name']
            enum_name = entry['enum_name']
            lines.append(f'        "{export_name}": Material.{enum_name},')
        
        lines.extend([
        '    }',
        '',
        '',
        # Getter functions
        'def get_item_mapping():',
        '    """Get the export name to Item mapping (lazy loaded)."""',
        '    global _EXPORT_NAME_TO_ITEM',
        '    if _EXPORT_NAME_TO_ITEM is None:',
        '        _EXPORT_NAME_TO_ITEM = _build_item_mapping()',
        '    return _EXPORT_NAME_TO_ITEM',
        '',
        'def get_consumable_mapping():',
        '    """Get the export name to Consumable mapping (lazy loaded)."""',
        '    global _EXPORT_NAME_TO_CONSUMABLE',
        '    if _EXPORT_NAME_TO_CONSUMABLE is None:',
        '        _EXPORT_NAME_TO_CONSUMABLE = _build_consumable_mapping()',
        '    return _EXPORT_NAME_TO_CONSUMABLE',
        '',
        'def get_material_mapping():',
        '    """Get the export name to Material mapping (lazy loaded)."""',
        '    global _EXPORT_NAME_TO_MATERIAL',
        '    if _EXPORT_NAME_TO_MATERIAL is None:',
        '        _EXPORT_NAME_TO_MATERIAL = _build_material_mapping()',
        '    return _EXPORT_NAME_TO_MATERIAL',
        '',
        'def get_export_name_mapping():',
        '    """Get combined mapping of all export names (lazy loaded)."""',
        '    global _EXPORT_NAME_TO_ANY',
        '    if _EXPORT_NAME_TO_ANY is None:',
        '        # Build combined mapping by merging all three',
        '        _EXPORT_NAME_TO_ANY = {}',
        '        _EXPORT_NAME_TO_ANY.update(get_item_mapping())',
        '        _EXPORT_NAME_TO_ANY.update(get_consumable_mapping())',
        '        _EXPORT_NAME_TO_ANY.update(get_material_mapping())',
        '    return _EXPORT_NAME_TO_ANY',
        '',
        '',
        # Helper functions
        'def get_item_from_export_name(export_name: str, item_type: str = None) -> Optional[Union[object, object, object]]:',
        '    """',
        '    Get Item/Consumable/Material from export name string, handling quality/fine suffixes.',
        '    ',
        '    WARNING: Due to circular imports between equipment.py and walkscape_constants.py,',
        '    this function should only be called AFTER those modules are fully loaded.',
        '    If you get ImportError, specify item_type parameter to avoid loading all mappings.',
        '    ',
        '    Args:',
        '        export_name: The export name to look up (e.g., "iron_sword", "beer", "bronze_bar")',
        '        item_type: Optional type hint to avoid circular imports:',
        '                   "equipment", "consumable", or "material"',
        '    ',
        '    Returns:',
        '        The Item/Consumable/Material object, or None if not found',
        '    """',
        '    export_lower = export_name.lower()',
        '    ',
        '    # If type is specified, only search that mapping to reduce circular import risk',
        '    if item_type == "equipment":',
        '        mapping = get_item_mapping()',
        '    elif item_type == "consumable":',
        '        mapping = get_consumable_mapping()',
        '    elif item_type == "material":',
        '        mapping = get_material_mapping()',
        '    else:',
        '        # Search all mappings (may cause circular import during module initialization)',
        '        mapping = get_export_name_mapping()',
        '    ',
        '    # Try exact match first',
        '    item = mapping.get(export_lower)',
        '    if item:',
        '        return item',
        '    ',
        '    # Try removing quality suffix for equipment (e.g., "iron_sword_uncommon" -> "iron_sword")',
        '    quality_map = {',
        '        "_common": "NORMAL",',
        '        "_uncommon": "GOOD",',
        '        "_rare": "GREAT",',
        '        "_epic": "EXCELLENT",',
        '        "_legendary": "PERFECT",',
        '        "_ethereal": "ETERNAL"',
        '    }',
        '    ',
        '    for suffix, quality_name in quality_map.items():',
        '        if export_lower.endswith(suffix):',
        '            base_name = export_lower[:-len(suffix)]',
        '            base_item = mapping.get(base_name)',
        '            if base_item and hasattr(base_item, quality_name):',
        '                return getattr(base_item, quality_name)',
        '    ',
        '    # Try removing "_fine" suffix for consumables/materials',
        '    if export_lower.endswith("_fine"):',
        '        base_name = export_lower[:-5]  # Remove "_fine"',
        '        # Look up the fine variant directly (e.g., "fruit_cake_fine" in mapping)',
        '        fine_item = mapping.get(export_lower)',
        '        if fine_item:',
        '            return fine_item',
        '        # Fall back to base item if fine variant not in mapping',
        '        base_item = mapping.get(base_name)',
        '        if base_item:',
        '            return base_item',
        '    else:',
        '        # Try adding _fine',
        '        fine_name = export_lower + "_fine"',
        '        fine_item = mapping.get(fine_name)',
        '        if fine_item:',
        '            return fine_item',
        '    ',
        '    return None',
        '',
        '',
        '# Backward compatibility aliases',
        'EXPORT_NAME_TO_ITEM = get_item_mapping',
        ])
        
        write_lines(f, lines)
    
    print(f"âœ“ Generated {output_file}")
    print(f"  - {len(equipment)} equipment items")
    print(f"  - {len(consumables)} consumables")
    print(f"  - {len(materials)} materials")
    print(f"  - {len(export_names)} total export names")

if __name__ == '__main__':
    export_names = extract_all_export_names()
    print(f"\nTotal: {len(export_names)} export names")
    
    generate_export_names_module(export_names)
