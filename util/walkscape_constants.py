#!/usr/bin/env python3
"""
Walkscape Constants
All static game data that doesn't change per user.
Re-exports all autogenerated data for convenient access.
"""

from enum import Enum
from typing import Union, Optional


# ============================================================================
# QUALITY MAPPINGS
# ============================================================================

# Map from display name (in item names) to gearset export format
QUALITY_NAME_TO_EXPORT = {
    'Eternal': 'ethereal',
    'Perfect': 'legendary',
    'Excellent': 'epic',
    'Great': 'rare',
    'Good': 'uncommon',
    'Normal': 'common'
}

# Map from gearset export format to display name
QUALITY_EXPORT_TO_NAME = {
    'ethereal': 'ETERNAL',
    'legendary': 'PERFECT',
    'epic': 'EXCELLENT',
    'rare': 'GREAT',
    'uncommon': 'GOOD',
    'common': 'NORMAL'
}


# ============================================================================
# KEYWORD CONSTANTS
# ============================================================================

# Keywords that can be shared between tools (no uniqueness constraint)
EXCLUDED_TOOL_KEYWORDS = frozenset({
    'regional',
    'tool',
    'light source',
    'achievement reward',
    'faction reward',
    'activity tool',
    'crafting tool'  # Multiple crafting tools can be equipped
})

# Keywords that are handled specially in optimization (not generic requirements)
SPECIAL_REQUIREMENT_KEYWORDS = frozenset({
    'diving gear',
    'advanced diving gear',
    'light source',
    'skis'
})


# ============================================================================
# KEYWORD HELPER FUNCTIONS
# ============================================================================

def get_diving_gear_requirement(keyword_counts: dict) -> int:
    """
    Get diving gear requirement from keyword_counts.
    
    Handles the fact that 'advanced diving gear' items also have 'diving gear' keyword.
    
    Args:
        keyword_counts: Dictionary of keyword -> count from activity requirements
        
    Returns:
        Number of diving gear items required
    """
    # Advanced diving gear takes precedence
    if keyword_counts.get('advanced diving gear', 0) > 0:
        return keyword_counts['advanced diving gear']
    return keyword_counts.get('diving gear', 0)


def item_has_keyword(item, keyword: str) -> bool:
    """
    Check if item has a specific keyword (case-insensitive).
    
    Args:
        item: Item object with keywords attribute
        keyword: Keyword to check for
        
    Returns:
        True if item has the keyword, False otherwise
    """
    if not hasattr(item, 'keywords'):
        return False
    return any(keyword.lower() in kw.lower() for kw in item.keywords)


def item_has_any_keyword(item, keywords: set) -> bool:
    """
    Check if item has any of the specified keywords.
    
    Args:
        item: Item object with keywords attribute
        keywords: Set of keywords to check for
        
    Returns:
        True if item has any of the keywords, False otherwise
    """
    if not hasattr(item, 'keywords'):
        return False
    item_keywords = {kw.lower() for kw in item.keywords}
    return bool(item_keywords & {k.lower() for k in keywords})


# ============================================================================
# ENUMS - Must be defined BEFORE importing autogenerated files
# ============================================================================
# Region enum
class SortingType(Enum):
    """Types for Sorting"""
    RECIPE = "recipe"
    ACTIVITY = "activity"

# Sorting enum for optimizers
class Sorting(Enum):
    """Sorting options for optimization results
    
    Format: (sort_direction, metric_key, display_name)
    - sort_direction: "+metric" for maximize, "-metric" for minimize
    - metric_key: Actual key in metrics dict
    - display_name: User-friendly name for display
    """
    
    def __new__(cls, sort_direction, metric_key, display_name, types):
        """Create enum with tuple values while maintaining backward compatibility"""
        obj = object.__new__(cls)
        obj._value_ = sort_direction  # Keep original value for backward compat
        obj._sort_direction = sort_direction
        obj._metric_key = metric_key
        obj._display_name = display_name
        obj._types = types
        return obj
    
    # Enum values: (sort_direction, metric_key, display_name, SortingType)
    STEPS_PER_REWARD_ROLL = ("-steps_per_reward_roll", "steps_per_reward_roll", "Minimize Steps/Reward Roll (or target item)", [SortingType.ACTIVITY])
    MATERIALS = ("-materials_for_target", "materials_for_target", "Materials for X Quality", [SortingType.RECIPE])
    TOTAL_CRAFTS_FOR_TARGET = ("-total_crafts", "total_crafts", "Total Crafts", [SortingType.RECIPE])
    STEPS_PER_CRAFT = ("-current_steps", "current_steps", "Steps/Craft", [SortingType.RECIPE])
    MATERIALS_PER_CRAFT = ("-materials_per_craft", "materials_per_craft", "Materials/Craft", [SortingType.RECIPE])
    TOTAL_XP_PER_STEP = ("+total_xp_per_step", "total_xp_per_step", "Total XP/Step (of all skills)", [SortingType.ACTIVITY])
    XP_PER_STEP = ("+primary_xp_per_step", "primary_xp_per_step", "Primary XP/Step", [SortingType.ACTIVITY, SortingType.RECIPE])
    TOTAL_XP = ("+total_xp_for_action", "total_xp_for_action", "Total XP per Action (of all skills)", [SortingType.ACTIVITY])
    EXPECTED_STEPS_PER_ACTION = ("-expected_steps_per_action", "expected_steps_per_action", "Steps/Action", [SortingType.ACTIVITY])
    TOTAL_STEPS = ("-steps_for_target", "steps_for_target", "Total Steps for X Quality", [SortingType.RECIPE])
    PRIMARY_XP = ("+primary_xp_per_action", "primary_xp_per_action", "Primary XP per Action", [SortingType.ACTIVITY, SortingType.RECIPE])
    STEPS_PER_CHEST = ("-steps_for_chest", "steps_for_chest", "Minimize Steps/Chest", [SortingType.RECIPE])

    @property
    def is_reverse(self):
        """Check if this sorting should be reversed (descending/maximize)"""
        return self._sort_direction.startswith('+')
    
    @property
    def stat_key(self):
        """Get the stat key without the +/- prefix (legacy)"""
        return self._sort_direction[1:]
    
    @property
    def metric_key(self):
        """Get the actual key used in metrics dict"""
        return self._metric_key

    @property
    def types(self):
        """Get the types for sorting"""
        return self._types
    
    @property
    def display_name(self):
        """Get user-friendly display name"""
        return self._display_name
    
    def get_sort_value(self, metrics: dict) -> float:
        """Get the sortable value from metrics dict (negated if maximizing)"""
        value = metrics.get(self._metric_key, 0.0)
        return -value if self.is_reverse else value
    
    def get_sort_from_number(self, metric): 
        """Legacy method for backward compatibility"""
        if self.is_reverse:
            return -metric
        return metric
    
    @staticmethod
    def compare_by_priority(metrics_a: dict, metrics_b: dict, priority_list: list) -> int:
        """
        Compare two metrics dicts using priority list.
        
        Args:
            metrics_a: First metrics dict
            metrics_b: Second metrics dict
            priority_list: List of Sorting enums (primary, secondary, tertiary, etc.)
        
        Returns:
            -1 if a is better, 1 if b is better, 0 if equal
        """
        for sorting in priority_list:
            val_a = sorting.get_sort_value(metrics_a)
            val_b = sorting.get_sort_value(metrics_b)
            
            if val_a < val_b:
                return True  # a is better (lower is better after negation)
            elif val_a > val_b:
                return False # b is better
            # Equal, continue to next priority
        
        return False  # All equal
    
    @staticmethod
    def is_better(metrics_new: dict, metrics_old: dict, priority_list: list) -> bool:
        """
        Check if new metrics are better than old metrics.
        
        Args:
            metrics_new: New metrics dict to test
            metrics_old: Old/current metrics dict (can be None for first iteration)
            priority_list: List of Sorting enums (primary, secondary, tertiary, etc.)
        
        Returns:
            True if new metrics are better, False otherwise
        """
        if metrics_old is None:
            return True  # First valid result is always "better"
        
        return Sorting.compare_by_priority(metrics_new, metrics_old, priority_list)

# Region enum
class Region(Enum):
    """Regions or Location keywords in Walkscape"""
    JARVONIA = "jarvonia"
    GDTE = "gdte"
    TRELLIN = "trellin"
    ERDWISE = "erdwise"
    HALFLING_REBELS = "halfling_rebels"
    SYRENTHIA = "syrenthia"
    WALLISIA = "wallisia"
    WRENTMARK = "wrentmark"
    # keywords
    UNDERWATER = "underwater"
    SPECTRAL = "spectral"


# Skill class with matching methods
class SkillInstance:
    """Individual skill instance with matching methods"""
    
    def __init__(self, name: str, value: str, component_skills: list = None):
        """
        Args:
            name: Display name (e.g., "COOKING")
            value: Internal value (e.g., "cooking")
            component_skills: List of skill values this skill combines (for TRAVEL)
        """
        self.name = name
        self.value = value
        self.component_skills = component_skills or [value]
    
    def matches_skill(self, stats_skill: str) -> bool:
        """
        Check if this skill matches a stats skill key.
        
        Args:
            stats_skill: Skill key from stats dict (e.g., "cooking", "global", "agility", "gathering", "artisan", "utility")
        
        Returns:
            True if this skill should include stats from stats_skill
        
        Examples:
            Skill.COOKING.matches_skill("cooking") -> True
            Skill.COOKING.matches_skill("global") -> True
            Skill.COOKING.matches_skill("artisan") -> True (cooking is artisan)
            Skill.FORAGING.matches_skill("gathering") -> True (foraging is gathering)
            Skill.AGILITY.matches_skill("utility") -> True (agility is utility)
            Skill.TRAVEL.matches_skill("agility") -> True
            Skill.TRAVEL.matches_skill("traveling") -> True
            Skill.TRAVEL.matches_skill("global") -> True
        """
        # Handle None stats_skill (from malformed data)
        if stats_skill is None:
            return False
        
        stats_skill_lower = stats_skill.lower()
        
        # Always match global
        if stats_skill_lower == "global":
            return True
        
        # Check skill categories (for pets and other items that use categories)
        if stats_skill_lower == "gathering":
            # Gathering: Fishing, Foraging, Mining, Woodcutting
            return self.value.lower() in ["fishing", "foraging", "mining", "woodcutting"]
        
        if stats_skill_lower == "artisan":
            # Artisan: Carpentry, Cooking, Crafting, Smithing, Trinketry
            return self.value.lower() in ["carpentry", "cooking", "crafting", "smithing", "trinketry"]
        
        if stats_skill_lower == "utility":
            # Utility: Agility
            return self.value.lower() == "agility"
        
        # Check if stats_skill is in our component skills
        return stats_skill_lower in self.component_skills
    
    def get_component_skills(self) -> list:
        """Get all component skills (for iterating when combining stats)"""
        return self.component_skills.copy()
    
    def __str__(self):
        return self.name
    
    def __repr__(self):
        return f"Skill.{self.name}"
    
    def __eq__(self, other):
        if isinstance(other, SkillInstance):
            return self.value == other.value
        return False
    
    def __hash__(self):
        return hash(self.value)


# Skill enum - container for all skill instances
class Skill:
    """Container for all skill instances - use like Skill.COOKING, Skill.TRAVEL, etc."""
    AGILITY = SkillInstance("AGILITY", "agility")
    CARPENTRY = SkillInstance("CARPENTRY", "carpentry")
    COOKING = SkillInstance("COOKING", "cooking")
    CRAFTING = SkillInstance("CRAFTING", "crafting")
    FISHING = SkillInstance("FISHING", "fishing")
    FORAGING = SkillInstance("FORAGING", "foraging")
    MINING = SkillInstance("MINING", "mining")
    SMITHING = SkillInstance("SMITHING", "smithing")
    TRINKETRY = SkillInstance("TRINKETRY", "trinketry")
    WOODCUTTING = SkillInstance("WOODCUTTING", "woodcutting")
    GLOBAL = SkillInstance("GLOBAL", "global")
    TRAVELING = SkillInstance("TRAVELING", "traveling")
    # Special: combines multiple skills; used when actually getting final travel stats, 
    # not just "when traveling" stats
    TRAVEL = SkillInstance("TRAVEL", "travel", ["agility", "traveling"])  

class ServiceCategory(Enum):
    BANK = "Bank"
    TRINKETRY = "Trinketry"
    SMITHING = "Smithing"
    COOKING = "Cooking"
    CARPENTRY = "Carpentry"
    CRAFTING = "Crafting"

class ServiceTier(Enum):
    BASIC = 1
    ADVANCED = 2

class ServicePrefix(Enum):
    BANK = "B:"
    TRINKETRY = "T:"
    COOKING = "K:"
    CARPENTRY = "C:"
    SMITHING = "S:"
    CRAFTING = "R:"


# ============================================================================
# AUTOGENERATED DATA - Import after enums to avoid circular imports
# ============================================================================

from util.attributes import * 
from util.autogenerated.locations import Location, LocationInfo
from util.autogenerated.equipment import Item
from util.autogenerated.materials import Material
from util.autogenerated.consumables import Consumable
from util.autogenerated.recipes import Recipe, RECIPES_BY_NAME, RECIPES_BY_SKILL
from util.autogenerated.services import Service, SERVICES_BY_NAME, SERVICES_BY_CATEGORY
from util.autogenerated.collectibles import Collectible, COLLECTIBLES_BY_NAME, by_export_name as collectible_by_export_name
from util.autogenerated.routes import RAW_ROUTES
from util.autogenerated.activities import Activity, ACTIVITIES_BY_NAME
from util.autogenerated.export_names import get_item_from_export_name, EXPORT_NAME_TO_ITEM
from util.autogenerated.containers import Container, CONTAINERS_BY_NAME, UNIQUE_OPENABLES, SKILL_CHESTS
from util.autogenerated.pets import Pet, Egg, EGGS_BY_NAME, PETS_BY_NAME


# ============================================================================
# SERVICE HELPER FUNCTIONS
# ============================================================================
def base_service(service: ServiceCategory, location: Union[Location, str], tier: ServiceTier = ServiceTier.BASIC) -> str:
    """Mark location as requiring service visit."""
    # Location enum values are LocationInfo objects with .name attribute
    if isinstance(location, Location):
        loc_str = location.name
    elif hasattr(location, 'name'):
        loc_str = location.name
    else:
        loc_str = str(location)
    prefix = ServicePrefix[service.name].value
    if tier == ServiceTier.ADVANCED:
        prefix = prefix[:-1] + "A:"  # Change "X:" to "XA:"
    return prefix + loc_str

def b(location: Union[Location, str], tier: ServiceTier = ServiceTier.BASIC) -> str:
    """Mark location as requiring bank visit."""
    return base_service(ServiceCategory.BANK, location, tier)

def t(location: Union[Location, str], tier: ServiceTier = ServiceTier.BASIC) -> str:
    """Mark location as requiring trinketry bench visit."""
    return base_service(ServiceCategory.TRINKETRY, location, tier)

def cook(location: Union[Location, str], tier: ServiceTier = ServiceTier.BASIC) -> str:
    """Mark location as requiring cooking service visit."""
    return base_service(ServiceCategory.COOKING, location, tier)

def carp(location: Union[Location, str], tier: ServiceTier = ServiceTier.BASIC) -> str:
    """Mark location as requiring carpentry service visit."""
    return base_service(ServiceCategory.CARPENTRY, location, tier)

def smith(location: Union[Location, str], tier: ServiceTier = ServiceTier.BASIC) -> str:
    """Mark location as requiring smithing service visit."""
    return base_service(ServiceCategory.SMITHING, location, tier)

def craft(location: Union[Location, str], tier: ServiceTier = ServiceTier.BASIC) -> str:
    """Mark location as requiring crafting service visit."""
    return base_service(ServiceCategory.CRAFTING, location, tier)

# Advanced service shortcuts
def ta(location: Union[Location, str]) -> str:
    """Advanced trinketry bench."""
    return t(location, ServiceTier.ADVANCED)

def cooka(location: Union[Location, str]) -> str:
    """Advanced cooking service."""
    return cook(location, ServiceTier.ADVANCED)

def carpa(location: Union[Location, str]) -> str:
    """Advanced carpentry service."""
    return carp(location, ServiceTier.ADVANCED)

def smitha(location: Union[Location, str]) -> str:
    """Advanced smithing service."""
    return smith(location, ServiceTier.ADVANCED)

def crafta(location: Union[Location, str]) -> str:
    """Advanced crafting service."""
    return craft(location, ServiceTier.ADVANCED)



# Region mappings for location-based equipment requirements
LOCATION_REGIONS = {
    # Jarvonia
    Location.AZURAZERA: Region.JARVONIA,
    Location.BARBANTOK: Region.JARVONIA,
    Location.BEACH_OF_WOES: Region.JARVONIA,
    Location.BLACK_EYE_PEAK: Region.JARVONIA,
    Location.CASBRANT_FIELDS: Region.JARVONIA,
    Location.CENTAHAM: Region.JARVONIA,
    Location.COLDINGTON: Region.JARVONIA,
    Location.DISENCHANTED_FOREST: Region.JARVONIA,
    Location.FORT_OF_PERMAFROST: Region.JARVONIA,
    Location.FROSTBITE_MOUNTAIN: Region.JARVONIA,
    Location.FRUSENHOLM: Region.JARVONIA,
    Location.HORN_OF_RESPITE: Region.JARVONIA,
    Location.KALLAHEIM: Region.JARVONIA,
    Location.NOMAD_WOODS: Region.JARVONIA,
    Location.NOISELESS_PASS: Region.JARVONIA,
    Location.NORSACK_PLAINS: Region.JARVONIA,
    Location.NURTURING_NOOK_SPRINGS: Region.JARVONIA,
    Location.PIT_OF_PITTANCE: Region.JARVONIA,
    Location.PORT_SKILDAR: Region.JARVONIA,
    Location.SANGUINE_HILLS: Region.JARVONIA,
    Location.WINTER_WAVES_GLACIER: Region.JARVONIA,
    Location.WINTERS_END: Region.JARVONIA,
    
    # Trellin (GDTE)
    Location.MANGROVE_FOREST: Region.TRELLIN,
    Location.FARSAND_COAST: Region.TRELLIN,
    Location.SALSFIRTH: Region.TRELLIN,
    Location.GRANFIDDICH_SHORES: Region.TRELLIN,
    Location.GRANFIDDICH: Region.TRELLIN,
    Location.WARRENFIELD: Region.TRELLIN,
    
    # Erdwise (GDTE)
    Location.OLD_ARENA_RUINS: Region.ERDWISE,
    Location.BLACKSPELL_PORT: Region.ERDWISE,
    Location.EVERHAVEN: Region.ERDWISE,
    Location.BILGEMONT_PORT: Region.ERDWISE,
    Location.RED_COAST: Region.ERDWISE,
    
    # Halfling Rebels (GDTE - swamp areas)
    Location.WITCHED_WOODS: Region.HALFLING_REBELS,
    Location.HALFLING_CAMPGROUNDS: Region.HALFLING_REBELS,
    Location.HALFMAW_HIDEOUT: Region.HALFLING_REBELS,
    Location.BOG_TOP: Region.HALFLING_REBELS,
    Location.BOG_BOTTOM: Region.HALFLING_REBELS,
    
    # Syrenthia (underwater)
    Location.CASBRANTS_GRAVE: Region.SYRENTHIA,
    Location.DARKTIDE_TRENCH: Region.SYRENTHIA,
    Location.ELARAS_LAGOON: Region.SYRENTHIA,
    Location.KELP_FOREST: Region.SYRENTHIA,
    Location.UNDERWATER_CAVE: Region.SYRENTHIA,
    Location.VASTALUME: Region.SYRENTHIA,
}


def get_location_region(location: Union[Location, str]) -> Optional[Region]:
    """Get the region for a location"""
    if isinstance(location, str):
        # Try to find matching Location enum
        for loc_enum in Location:
            if loc_enum.value == location:
                return LOCATION_REGIONS.get(loc_enum)
        return None
    return LOCATION_REGIONS.get(location)


# ============================================================================
# XP AND LEVEL TABLES
# ============================================================================

# XP required for each level (index = level, value = total XP needed)
#   X0       X1       X2       X3       X4       X5       X6        X7        X8       X9        X0
LEVEL_XP = [
             0,       83,      174,     276,     388,     512,     650,      801,      969,
    #10
    1154,    1358,    1584,    1833,    2107,    2411,    2746,    3115,     3523,     3973,
    #20
    4470,    5018,    5624,    6291,    7028,    7842,    8740,    9730,     10824,    12031,
    #30
    13363,   14833,   16456,   18247,   20224,   22406,   24815,   27473,    30408,    33648,
    #40
    37224,   41171,   45529,   50339,   55649,   61512,   67983,   75127,    83014,    91721,
    #50
    101333,  111945,  123660,  136594,  150872,  166636,  184040,  203254,   224466,   247886,  
    #60
    273742,  302288,  333804,  368599,  407015,  449428,  496254,  547953,   605032,   668051,
    #70
    737627,  814445,  899257,  992895,  1096278, 1210421, 1336443, 1475581,  1629200,  1798808, 
    #80
    1986068, 2192818, 2421087, 2673114, 2951373, 3258594, 3597792, 3972294,  4385776,  4842295, 
    #90
    5346332, 5902831, 6517253, 7195629, 7944614, 8771558, 9684577, 10692629, 11805606, 13034431,
]


def xp_to_level(xp: int) -> int:
    """Convert XP to level"""
    for level, required_xp in enumerate(LEVEL_XP, start=1):
        if xp < required_xp:
            return level - 1
    return 99  # Max level


def level_to_xp(level: int) -> int:
    """Get XP required for a level"""
    if level < 1:
        return 0
    if level > 99:
        return LEVEL_XP[-1]
    return LEVEL_XP[level - 1]


def xp_equate(level: float) -> int:
    """XP equation algorithm for character level"""
    return int(level + 300 * (2 ** (level / 7)))


def xp_to_level_character(level: int) -> float:
    """Calculate the experience needed to level up character level"""
    xp = 0.0
    for i in range(1, level + 1):
        xp += xp_equate(float(i))
    return (int(xp / 4) * 4.6)


def character_level_from_steps(steps: int) -> int:
    """Calculate character level from total steps"""
    char_level = 1
    while char_level < 999:
        required_xp = xp_to_level_character(char_level + 1)
        if steps < required_xp:
            break
        char_level += 1
    return char_level


def tool_slots_for_level(char_level: int) -> int:
    """Get number of tool slots available at a given character level"""
    if char_level >= 80:
        return 6
    elif char_level >= 50:
        return 5
    elif char_level >= 20:
        return 4
    else:
        return 3
