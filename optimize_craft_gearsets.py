#!/usr/bin/env python3
"""
Optimize gearsets for crafting efficiency using greedy + local search.

Finds best gear combinations to minimize steps or materials for crafting.
Uses the proven greedy initialization + local search refinement algorithm.
"""

# Standard library imports
import math
import time
from typing import Dict, List, Optional, Tuple

# Local imports
from my_config import get_character
from util.activity_metrics import calculate_crafting_metrics
from util.gearset_utils import aggregate_gearset_stats, encode_gearset, Gearset, is_gearset_valid
from util.autogenerated.equipment import Item
from util.greedy_local_search import (
    optimize_gearset_greedy_local_search,
    create_multi_level_comparator,
    prepare_items_by_slot
)
from util.optimization_utils import (
    filter_items_by_quality,
    filter_ignored_items,
    filter_items_by_stats
)
from util.quality_outcome import calculate_quality_weights
from util.walkscape_constants import *

# ============================================================================
# CONFIGURATION
# ============================================================================

# Recipe and service
RECIPE = Recipe.CORAL_FISHING_SPEAR
SERVICE = Service.BASIC_WORKSHOP_FRUSENHOLM  # Or None to auto-select
SKILL_LEVEL = None  # None = auto-detect from character

# Target configuration
TARGET_QUALITY = 'Perfect'  # 'Normal', 'Good', 'Great', 'Excellent', 'Perfect', 'Eternal'
TARGET_QUALITY_QUANTITY = 1  # How many of this quality to craft

# Consumable options
CONSUMABLE = None  # Specific consumable or None to find best
INCLUDE_CONSUMABLES = False  # Disable for faster testing

# Array of sorting priorities (first = primary, second = tiebreaker, etc.)
SORTING_PRIORITY = [
    Sorting.MATERIALS,              # Primary: minimize materials for target
    Sorting.TOTAL_STEPS,            # Tiebreaker 1: minimize total steps
    Sorting.STEPS_PER_CRAFT,        # Tiebreaker 2: minimize steps per craft
]

# Display options
VERBOSE = False
MAX_ITERATIONS = 100

# Items to ignore
IGNORED_ITEMS = {
    Item.HERBERTS_BOOTS, Item.HERBERTS_CAPE, Item.HERBERTS_HAT,
    Item.HERBERTS_SHIRT, Item.HERBERTS_PANTS,
    Item.KELP_DIVING_MASK, Item.KELP_DIVING_PANTS, Item.KELP_DIVING_SHIRT,
    Item.RUSTY_DIVING_HELMET, Item.RUSTY_DIVING_LEGGINGS, Item.RUSTY_DIVING_TORSO,
    Item.MERFOLK_DANCE_CIRCLET
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def get_available_services(recipe, character):
    """Get all unlocked services that can craft this recipe."""
    from util.autogenerated.services import SERVICES_BY_NAME
    
    available = []
    for service in SERVICES_BY_NAME.values():
        if service.is_valid_for_recipe(recipe) and service.is_unlocked(character):
            available.append(service)
    
    return available

def calculate_craft_metrics(
    gearset_dict: dict,
    recipe,
    service,
    character,
    target_quality: str,
    target_quantity: int,
    consumable=None
) -> Tuple[Dict[str, float], Dict[str, float]]:
    """
    Calculate all metrics for a crafting gearset (like activity optimizer pattern).
    
    Returns:
        Tuple of (metrics_dict, stats_dict)
    """
    # Get all items including consumable
    items = [item for item in gearset_dict.values() if item is not None]
    if consumable:
        items.append(consumable)
    
    # Aggregate stats
    skill = recipe.skill.lower()
    location = service.location if service else None
    
    total_stats = aggregate_gearset_stats(
        items=items,
        skill=skill,
        location=location,
        character=character,
        include_level_bonus=True,
        include_collectibles=True, 
        activity_level=recipe.level
    )
    
    # Add service stats
    if service:
        service_stats = service.get_stats_for_skill(
            skill=skill,
            location=location,
            character=character
        )
        for stat_name, stat_value in service_stats.items():
            total_stats[stat_name] = total_stats.get(stat_name, 0.0) + stat_value
    
    # Calculate crafting metrics using total_stats
    metrics = calculate_crafting_metrics(
        base_steps=recipe.base_steps,
        base_xp=recipe.base_xp,
        max_efficiency=recipe.max_efficiency,
        total_stats=total_stats
    )
    
    # Calculate expected crafts for target quality
    quality_weights = calculate_quality_weights(recipe.level, total_stats.get('quality_outcome', 0.0))
    target_percentage = quality_weights['percentages'][target_quality]
    expected_crafts = math.ceil(100.0 / target_percentage) * target_quantity
    
    # Calculate totals for target quantity using expected_steps_per_item
    total_materials = metrics['materials_per_craft'] * expected_crafts
    total_steps = metrics['expected_steps_per_item'] * expected_crafts
    
    # Store additional metrics for sorting
    metrics['materials_for_target'] = total_materials
    metrics['steps_for_target'] = total_steps
    metrics['total_crafts'] = expected_crafts
    metrics['perfect_percentage'] = quality_weights['percentages'].get('Perfect', 0.0)
    
    return metrics, total_stats

# ============================================================================
# MAIN OPTIMIZATION
# ============================================================================

def optimize_for_service(recipe, service, character, consumable=None):
    """Optimize gearset for a specific recipe, service, and optional consumable."""
    
    skill = recipe.skill.lower()
    location = service.location if service else None
    
    # Get tool slots based on character level
    from util.walkscape_constants import character_level_from_steps, tool_slots_for_level
    total_steps = sum(character.skills.values())
    char_level = character_level_from_steps(total_steps)
    max_tool_slots = tool_slots_for_level(char_level)
    
    # Define all slots
    gear_slots = ['head', 'cape', 'neck', 'chest', 'hands', 'legs', 'feet',
                  'ring1', 'ring2', 'back', 'primary', 'secondary']
    tool_slots = [f'tool{i}' for i in range(max_tool_slots)]
    all_slots = gear_slots + tool_slots
    
    # Slots that can have diving gear
    diving_gear_slots = ['head', 'chest', 'hands', 'legs', 'feet', 'back']
    
    # Check service requirements
    required_diving_gear = service.requirements.get('keyword_counts', {}).get('diving gear', 0)
    if not required_diving_gear:
        required_diving_gear = service.requirements.get('keyword_counts', {}).get('advanced diving gear', 0)
    
    if required_diving_gear > 0:
        print(f"  Service requires {required_diving_gear} diving gear items")
    
    # Get all items (filter by unlock status only, like activity optimizer)
    all_items = []
    excluded_count = 0
    for item, qty in character.items.items():
        if qty == 0 or not hasattr(item, 'slot'):
            continue
        if item in IGNORED_ITEMS:
            continue
        
        # Check if unlocked
        if hasattr(item, 'is_unlocked'):
            if not item.is_unlocked(character, ignore_gear_requirements=True):
                excluded_count += 1
                continue
        
        all_items.append(item)
    
    print(f"  Found {len(all_items)} items in inventory ({excluded_count} locked)")
    
    # Keep highest quality only
    all_items = filter_items_by_quality(all_items, keep_highest_only=True)
    
    print(f"  After quality filter: {len(all_items)} items")
    
    # If service requires diving gear, ensure we have diving gear items
    if required_diving_gear > 0:
        diving_items = [item for item in all_items 
                       if hasattr(item, 'keywords') and 
                       any('diving gear' in kw.lower() for kw in item.keywords)]
        print(f"  Found {len(diving_items)} diving gear items")
        
        if len(diving_items) < required_diving_gear:
            print(f"  ⚠ Warning: Not enough diving gear items ({len(diving_items)} < {required_diving_gear})")
            print(f"  Optimization may fail to meet service requirements")
    
    # Debug: show items by slot
    items_by_slot_debug = {}
    for item in all_items:
        slot_type = item.slot
        if slot_type not in items_by_slot_debug:
            items_by_slot_debug[slot_type] = []
        items_by_slot_debug[slot_type].append(item.name)
    
    print(f"  Items by slot type:")
    for slot_type, item_names in items_by_slot_debug.items():
        print(f"    {slot_type}: {len(item_names)} items")
        if len(item_names) <= 5:
            for name in item_names:
                print(f"      - {name}")
    
    # Prepare items by slot
    items_by_slot = {}
    for slot in all_slots:
        items_by_slot[slot] = []
        
        for item in all_items:
            # Match slot
            if slot.startswith('tool') and item.slot == 'tools':  # Note: slot is 'tools' (plural)
                items_by_slot[slot].append(item)
            elif slot.startswith('ring') and item.slot == 'ring':
                items_by_slot[slot].append(item)
            elif item.slot == slot:
                items_by_slot[slot].append(item)
        
        # Add None option for empty slots
        items_by_slot[slot].append(None)
        
        if VERBOSE and len(items_by_slot[slot]) > 1:  # More than just None
            print(f"  Slot {slot}: {len(items_by_slot[slot])-1} items")
    
    # Create scoring function
    def score_function(gearset_dict):
        metrics, stats = calculate_craft_metrics(
            gearset_dict, recipe, service, character,
            TARGET_QUALITY, TARGET_QUALITY_QUANTITY, consumable
        )
        return metrics
    
    # Create validation function
    # During greedy: only check UUID/keyword constraints
    # During local search: check full service requirements
    def validate_function(gearset_dict, check_service_reqs=False):
        if check_service_reqs:
            return is_gearset_valid(gearset_dict, character, activity=None, service=service, check_requirements=True)
        else:
            return is_gearset_valid(gearset_dict, character, activity=None, service=None, check_requirements=False)
    
    # Custom greedy initialization with diving gear enforcement (like activity optimizer)
    print("  Building gearset with diving gear requirements...")
    gearset = {}
    diving_gear_count = 0
    
    # Process gear slots first (in order that allows diving gear enforcement)
    for slot in gear_slots:
        item_slot = 'ring' if slot in ['ring1', 'ring2'] else slot
        
        # Determine if this slot MUST have diving gear
        must_have_diving_gear = (required_diving_gear > 0 and 
                                 diving_gear_count < required_diving_gear and 
                                 slot in diving_gear_slots)
        
        best_item = None
        best_score = None
        
        for item in items_by_slot.get(slot, []):
            if item is None:
                continue
            
            # Check if item has diving gear keyword
            has_diving_gear = (hasattr(item, 'keywords') and 
                             any('diving gear' in kw.lower() for kw in item.keywords))
            
            # Skip if we MUST have diving gear but item doesn't have it
            if must_have_diving_gear and not has_diving_gear:
                continue
            
            # Try this item
            test_gearset = gearset.copy()
            test_gearset[slot] = item
            
            # Validate (skip service requirements during greedy)
            if not validate_function(test_gearset, check_service_reqs=False):
                continue
            
            # Score
            try:
                metrics = score_function(test_gearset)
                metric_value = metrics[SORTING_PRIORITY[0].metric_key]
                if best_score is None or (SORTING_PRIORITY[0].is_reverse and metric_value > best_score) or (not SORTING_PRIORITY[0].is_reverse and metric_value < best_score):
                    best_item = item
                    best_score = metric_value
            except:
                continue
        
        # Use best item found
        gearset[slot] = best_item
        
        # Update diving gear count
        if best_item and hasattr(best_item, 'keywords'):
            if any('diving gear' in kw.lower() for kw in best_item.keywords):
                diving_gear_count += 1
    
    # Process tool slots
    for slot in tool_slots:
        best_item = None
        best_score = None
        
        for item in items_by_slot.get(slot, []):
            if item is None:
                continue
            
            test_gearset = gearset.copy()
            test_gearset[slot] = item
            
            # Skip service requirements during greedy
            if not validate_function(test_gearset, check_service_reqs=False):
                continue
            
            try:
                metrics = score_function(test_gearset)
                metric_value = metrics[SORTING_PRIORITY[0].metric_key]
                
                if best_score is None or (SORTING_PRIORITY[0].is_reverse and metric_value > best_score) or (not SORTING_PRIORITY[0].is_reverse and metric_value < best_score):
                    best_item = item
                    best_score = metric_value
            except:
                continue
        
        gearset[slot] = best_item
    
    print(f"  Initial gearset has {diving_gear_count} diving gear items")
    
    # Now do local search refinement
    current_metrics = score_function(gearset)
    current_value = current_metrics[SORTING_PRIORITY[0].metric_key]
    iteration = 0
    improved = True
    
    while improved and iteration < MAX_ITERATIONS:
        improved = False
        iteration += 1
        
        best_gearset_metrics = current_metrics
        best_swap = None
        best_swap_gearset = None
        best_swap_metrics = None
        
        # Phase 1: Try 1-item swaps (test ALL slots, find BEST swap)
        for slot in all_slots:
            current_item = gearset.get(slot)
            
            for item in items_by_slot.get(slot, []):
                if item is current_item:
                    continue
                
                test_gearset = gearset.copy()
                
                # If this item is already in another slot, remove it from there first
                # This allows moving items between slots (e.g., Screwdriver from tool0 to tool4)
                if item is not None and hasattr(item, 'uuid'):
                    for other_slot in all_slots:
                        if other_slot != slot:
                            other_item = gearset.get(other_slot)
                            if other_item and hasattr(other_item, 'uuid') and other_item.uuid == item.uuid:
                                test_gearset[other_slot] = None
                                break
                
                test_gearset[slot] = item
                
                # Validate (check service requirements during local search)
                if not validate_function(test_gearset, check_service_reqs=True):
                    continue
                
                try:
                    test_metrics = score_function(test_gearset)
                    
                    # Track best swap across ALL slots (don't break early!)
                    if Sorting.is_better(test_metrics, best_gearset_metrics, SORTING_PRIORITY):
                        best_swap = (slot, current_item, item)
                        best_swap_gearset = test_gearset.copy()
                        best_swap_metrics = test_metrics
                        best_gearset_metrics = test_metrics  # Update best for comparison
                        improved = True
                except Exception as e:
                    continue
        
        # Apply best swap found (if any)
        if improved and best_swap:
            slot, old_item, new_item = best_swap
            gearset = best_swap_gearset
            current_metrics = best_swap_metrics
            current_value = current_metrics[SORTING_PRIORITY[0].metric_key]
            
            if VERBOSE:
                old_name = old_item.name if old_item else "None"
                print(f"\n  Iteration {iteration}: Swapped {slot}: {old_name} → {new_item.name}")
                print(f"    Materials: {current_metrics.get('materials_for_target', 0):.1f}")
        
        # Phase 2: If no 1-item swap helped, try 2-item swaps (slower but escapes local optima)
        if not improved and required_diving_gear > 0:
            # Only test 2-swaps for diving gear slots (most common constraint issue)
            for slot1 in diving_gear_slots:
                if slot1 not in gearset:
                    continue
                    
                for slot2 in diving_gear_slots:
                    if slot2 <= slot1 or slot2 not in gearset:  # Only test each pair once
                        continue
                    
                    current_item1 = gearset.get(slot1)
                    current_item2 = gearset.get(slot2)
                    
                    for item1 in items_by_slot.get(slot1, []):
                        if item1 is current_item1:
                            continue
                        
                        for item2 in items_by_slot.get(slot2, []):
                            if item2 is current_item2:
                                continue
                            
                            # Try swapping both items
                            test_gearset = gearset.copy()
                            test_gearset[slot1] = item1
                            test_gearset[slot2] = item2
                            
                            if not validate_function(test_gearset, check_service_reqs=True):
                                continue
                            
                            try:
                                test_metrics = score_function(test_gearset)
                                
                                if Sorting.is_better(test_metrics, best_gearset_metrics, SORTING_PRIORITY):
                                    gearset = test_gearset
                                    current_metrics = test_metrics
                                    current_value = test_metrics[SORTING_PRIORITY[0].metric_key]
                                    best_gearset_metrics = test_metrics
                                    improved = True
                                    if VERBOSE:
                                        print(f"    Iteration {iteration}: 2-swap improved {slot1} + {slot2}")
                                    break
                            except:
                                continue
                        
                        if improved:
                            break
                    
                    if improved:
                        break
                
                if improved:
                    break
    
    print(f"  Converged in {iteration} iterations")
    
    best_gearset = gearset
    best_metrics = current_metrics
    iterations = iteration
    
    return best_gearset, best_metrics, iterations

# ============================================================================
# DISPLAY FUNCTIONS
# ============================================================================

def print_results(gearset_dict, metrics, recipe, service, character, consumable, iterations):
    """Print optimization results."""
    print("\n" + "=" * 80)
    print(f"OPTIMIZATION COMPLETE - {recipe.name}")
    print("=" * 80)
    
    print(f"\nRecipe: {recipe.name}")
    print(f"Service: {service.name}")
    print(f"Skill: {recipe.skill} (Level {character.get_skill_level(recipe.skill.lower())})")
    if consumable:
        print(f"Consumable: {consumable.name}")
    
    print(f"\nConverged in {iterations} iterations")
    priority_names = ' > '.join(s.display_name for s in SORTING_PRIORITY)
    print(f"Optimization goal: {priority_names}")
    
    # Recalculate full metrics for display
    items = [item for item in gearset_dict.values() if item is not None]
    if consumable:
        items.append(consumable)
    
    skill = recipe.skill.lower()
    location = service.location if service else None
    
    total_stats = aggregate_gearset_stats(
        items=items,
        skill=skill,
        location=location,
        character=character,
        include_level_bonus=True,
        include_collectibles=True,
        activity_level=recipe.level  # IMPORTANT: For correct level bonus calculation
    )
    
    # Add service stats
    if service:
        service_stats = service.get_stats_for_skill(
            skill=skill,
            location=location,
            character=character
        )
        for stat_name, stat_value in service_stats.items():
            total_stats[stat_name] = total_stats.get(stat_name, 0.0) + stat_value
    
    # Note: Level bonus is already included by aggregate_gearset_stats with activity_level parameter
    
    # Calculate metrics
    metrics = calculate_crafting_metrics(
        base_steps=recipe.base_steps,
        base_xp=recipe.base_xp,
        max_efficiency=recipe.max_efficiency,
        work_efficiency=total_stats.get('work_efficiency', 0.0),
        double_action=total_stats.get('double_action', 0.0),
        double_rewards=total_stats.get('double_rewards', 0.0),
        no_materials_consumed=total_stats.get('no_materials_consumed', 0.0),
        quality_outcome=total_stats.get('quality_outcome', 0.0),
        steps_add=int(total_stats.get('steps_add', 0.0)),
        steps_percent=total_stats.get('steps_percent', 0.0),
        bonus_xp_percent=total_stats.get('bonus_xp_percent', 0.0),
        bonus_xp_add=int(total_stats.get('bonus_xp_add', 0.0))
    )
    
    # Calculate quality outcome
    quality_weights = calculate_quality_weights(recipe.level, total_stats.get('quality_outcome', 0.0))
    target_percentage = quality_weights['percentages'][TARGET_QUALITY]
    expected_crafts = math.ceil(100.0 / target_percentage) * TARGET_QUALITY_QUANTITY
    
    # Calculate totals using expected_steps_per_item (accounts for DA and DR)
    total_materials = metrics['materials_per_craft'] * expected_crafts
    total_steps = metrics['expected_steps_per_item'] * expected_crafts
    
    print(f"\n{'Stat':<30} {'Value':>15}")
    print("-" * 45)
    print(f"{'Work Efficiency':<30} {total_stats.get('work_efficiency', 0.0)*100:>14.1f}%")
    print(f"{'Double Rewards':<30} {total_stats.get('double_rewards', 0.0)*100:>14.1f}%")
    print(f"{'Double Action':<30} {total_stats.get('double_action', 0.0)*100:>14.1f}%")
    print(f"{'No Materials Consumed':<30} {total_stats.get('no_materials_consumed', 0.0)*100:>14.1f}%")
    print(f"{'Quality Outcome':<30} {total_stats.get('quality_outcome', 0.0):>15.0f}")
    print(f"{'Flat Steps':<30} {int(total_stats.get('steps_add', 0.0)):>15d}")
    print(f"{'% Steps':<30} {total_stats.get('steps_percent', 0.0)*100:>14.1f}%")
    
    # Show stat breakdown
    if VERBOSE:
        print(f"\nStat Breakdown:")
        # Calculate gear-only stats
        gear_stats = aggregate_gearset_stats(
            items=[item for item in gearset_dict.values() if item is not None],
            skill=skill,
            location=location,
            character=character,
            include_level_bonus=False,
            include_collectibles=False,
            activity_level=recipe.level
        )
        # Calculate level bonus
        skill_level = character.get_skill_level(skill)
        levels_above = max(0, skill_level - recipe.level)
        level_bonus_we = min(levels_above, 20) * 0.0125
        level_bonus_qo = levels_above
        
        # Service stats
        service_stats = service.get_stats_for_skill(skill, location, character) if service else {}
        
        print(f"  Gear WE: {gear_stats.get('work_efficiency', 0.0)*100:.1f}%")
        print(f"  Level bonus WE: {level_bonus_we*100:.1f}%")
        print(f"  Service WE: {service_stats.get('work_efficiency', 0.0)*100:.1f}%")
        print(f"  Total WE: {total_stats.get('work_efficiency', 0.0)*100:.1f}%")
        print(f"  Gear QO: {gear_stats.get('quality_outcome', 0.0):.0f}")
        print(f"  Level bonus QO: {level_bonus_qo:.0f}")
        print(f"  Total QO: {total_stats.get('quality_outcome', 0.0):.0f}")
    
    print(f"\n{'Metric':<30} {'Value':>15}")
    print("-" * 45)
    print(f"{'Steps per craft':<30} {metrics['current_steps']:>15d}")
    print(f"{'Materials per craft':<30} {metrics['materials_per_craft']:>15.3f}")
    print(f"{'Crafts per material':<30} {metrics['crafts_per_material']:>15.2f}")
    print(f"{'XP per step':<30} {metrics['primary_xp_per_step']:>15.4f}")
    
    print(f"\n{'Target: ' + TARGET_QUALITY:<30} {'':>15}")
    print("-" * 45)
    print(f"{'Chance per craft':<30} {target_percentage:>14.2f}%")
    print(f"{'Expected crafts':<30} {expected_crafts:>15.0f}")
    print(f"{'Total materials needed':<30} {total_materials:>15.1f}")
    print(f"{'Total steps needed':<30} {total_steps:>15.0f}")
    
    print(f"\n{'Items in Gearset':<30}")
    print("-" * 45)
    for slot in sorted(gearset_dict.keys()):
        item = gearset_dict[slot]
        if item:
            print(f"  {slot:<12} {item.name}")
        else:
            print(f"  {slot:<12} (empty)")
    
    print(f"\nGearset Export String:")
    print(encode_gearset(gearset_dict))

# ============================================================================
# MAIN LOGIC
# ============================================================================

def main():
    """Main optimization logic."""
    start_time = time.time()
    
    print("=" * 80)
    print("CRAFT GEARSET OPTIMIZER - Greedy + Local Search")
    print("=" * 80)
    
    character = get_character()
    
    # Auto-detect skill level
    skill_level = SKILL_LEVEL
    if skill_level is None:
        skill_level = character.get_skill_level(RECIPE.skill.lower())
    
    print(f"\nRecipe: {RECIPE.name}")
    print(f"Skill: {RECIPE.skill} (Level {skill_level})")
    print(f"Target: {TARGET_QUALITY_QUANTITY}x {TARGET_QUALITY}")
    priority_names = ' > '.join(s.display_name for s in SORTING_PRIORITY)
    print(f"Optimize for: {priority_names}")
    
    # Get services
    if SERVICE is None:
        print("\nAuto-selecting best service...")
        services = get_available_services(RECIPE, character)
        print(f"Found {len(services)} available services")
    else:
        services = [SERVICE]
        print(f"\nUsing service: {SERVICE.name}")
    
    if not services:
        print("ERROR: No available services for this recipe!")
        return
    
    # Get consumables
    if INCLUDE_CONSUMABLES:
        consumables = [None]  # Start with no consumable
        for item, qty in character.items.items():
            if qty > 0 and hasattr(item, 'duration'):
                consumables.append(item)
        print(f"Testing {len(consumables)} consumable options")
    else:
        consumables = [CONSUMABLE] if CONSUMABLE else [None]
        print(f"Testing without consumables")
    
    print(f"\nStarting optimization...")
    
    # Optimize for each service and consumable combination
    best_overall = None
    best_overall_metrics = None
    best_service = None
    best_consumable = None
    
    for service in services:
        for consumable in consumables:
            print(f"\nTrying {service.name}" + (f" with {consumable.name}" if consumable else ""))
            
            try:
                gearset, metrics, iterations = optimize_for_service(
                    RECIPE, service, character, consumable
                )
                
                metric_value = metrics[SORTING_PRIORITY[0].metric_key]
                print(f"  ✓ Success! {SORTING_PRIORITY[0].display_name}: {metric_value:.2f}, Iterations: {iterations}")
                
                # Compare with best overall
                if best_overall_metrics is None or Sorting.is_better(metrics, best_overall_metrics, SORTING_PRIORITY):
                    best_overall = gearset
                    best_overall_metrics = metrics
                    best_service = service
                    best_consumable = consumable
                    print(f"  → New best!")
            except Exception as e:
                print(f"  ✗ Failed: {e}")
                import traceback
                traceback.print_exc()
                continue
    
    # Print results
    if best_overall:
        elapsed = time.time() - start_time
        print(f"\nOptimization completed in {elapsed:.1f} seconds")
        
        # Get iterations from last run (approximate)
        _, best_overall_metrics, iterations = optimize_for_service(RECIPE, best_service, character, best_consumable)
        
        print_results(
            best_overall, best_overall_metrics, RECIPE, best_service,
            character, best_consumable, iterations
        )
    else:
        print("\nERROR: No valid gearset found!")

# ============================================================================
# ENTRY POINT
# ============================================================================

if __name__ == '__main__':
    main()
