#!/usr/bin/env python3
"""
Optimize gearsets for activity efficiency - Version 11.
Fast greedy + local search refinement.

Approach:
1. Use V9's greedy algorithm to get initial solution (fast)
2. Refine using local search (swap each slot with all items)
3. Repeat until no improvements found
4. Guaranteed to find local optimum

This combines speed (greedy) with quality (local search refinement).
"""

# Standard library imports
import math
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

# Local imports
from my_config import get_character
from util.gearset_utils import aggregate_gearset_stats, encode_gearset, Gearset, is_gearset_valid
from util.autogenerated.activities import Activity
from util.optimization_utils import (
    is_gearset_complete,
    meets_activity_requirements,
    validate_tool_keywords,
    validate_uuid_uniqueness
)
from util.walkscape_constants import *

# ============================================================================
# CONFIGURATION
# ============================================================================

# Array of sorting priorities (first = primary, second = tiebreaker, etc.)
SORTING_PRIORITY = [
    Sorting.STEPS_PER_REWARD_ROLL,       # Primary: minimize steps per reward
    Sorting.XP_PER_STEP,                 # Tiebreaker 1: maximize XP per step
    Sorting.EXPECTED_STEPS_PER_ACTION,   # Tiebreaker 2: minimize steps per action
    Sorting.TOTAL_XP,
]

ACTIVITY = Activity.PLAINS_FORAGING

# Target a specific item drop (None = optimize for general activity efficiency)
# Supports strings, Item, Material, Collectible, Consumable, etc.
TARGET_ITEM = Material.FLAX

VERBOSE = True
SLOTS_TO_TEST = []
MAX_ITERATIONS = 100  # Max local search iterations

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def get_target_name(target) -> str:
    """Extract name from target (handles both string and object)."""
    if isinstance(target, str):
        return target
    elif hasattr(target, 'name'):
        return target.name
    return str(target)

def is_fine_material_target(target) -> bool:
    """Check if target is a fine material."""
    name = get_target_name(target)
    return "(Fine)" in name

def calculate_gearset_metrics(gearset_dict: dict, activity, character, final: bool = False) -> Dict[str, float]:
    """
    Calculate metrics for a complete gearset using Activity's get_expected_drop_rate.
    
    This function aggregates stats and calls activity.get_expected_drop_rate(verbose=True)
    which returns comprehensive metrics including all efficiency calculations.
    """
    # Get all items from gearset
    items = [item for item in gearset_dict.values() if item is not None]
    
    # Aggregate all stats using shared function
    skill = activity.primary_skill.lower()
    location = activity.locations[0] if activity.locations else None
    
    total_stats = aggregate_gearset_stats(
        items=items,
        skill=skill,
        location=location,
        character=character, 
        include_level_bonus=False,
        include_collectibles=False
    )
    
    # Use activity's get_expected_drop_rate with verbose=True to get all metrics
    drop_rates, metrics = activity.get_expected_drop_rate(
        total_stats, 
        location=location, 
        target_item=TARGET_ITEM,
        verbose=True,
        character=character
    )
    
    # If targeting a specific item, override steps_per_reward_roll
    if TARGET_ITEM is not None:
        try:
            # Extract target name (handle both string and object)
            target_name = get_target_name(TARGET_ITEM)
            
            if target_name in drop_rates:
                # Override steps_per_reward_roll with steps per specific item
                metrics['steps_per_reward_roll'] = drop_rates[target_name]
                metrics['reward_rolls_per_step'] = 1.0 / drop_rates[target_name] if drop_rates[target_name] > 0 else 0
            else:
                # Target item not in drop table
                if VERBOSE:
                    print(f"  Warning: {target_name} not found in drop rates (available: {list(drop_rates.keys())})")
                # Use a penalty value
                metrics['steps_per_reward_roll'] = 999999.0
                metrics['reward_rolls_per_step'] = 0.0
        except Exception as e:
            # If calculation fails, use a very high penalty value
            if VERBOSE:
                print(f"  Warning: Could not calculate drop rate: {e}")
            metrics['steps_per_reward_roll'] = 999999.0
            metrics['reward_rolls_per_step'] = 0.0
    
    if final: 
        # Needed to get the collectibles in the final dispaly 
        total_stats = aggregate_gearset_stats(
            items=items,
            skill=skill,
            location=location,
            character=character, 
            include_level_bonus=False,
            include_collectibles=True
        )
    
    return metrics, total_stats

# ============================================================================
# GREEDY INITIAL SOLUTION (from V9)
# ============================================================================

def get_greedy_initial_solution(activity, character) -> dict:
    """
    Get initial solution using greedy algorithm (fast).
    Returns gearset dict.
    """
    print("Getting initial solution (greedy)...")
    
    # Simple greedy: pick best item per slot
    gearset = {}
    skill = activity.primary_skill.lower()
    location = activity.locations[0] if activity.locations else None
    
    # Get all items (filter by unlock status)
    all_items = []
    excluded_count = 0
    for item, qty in character.items.items():
        if qty > 0 and hasattr(item, 'get_stats_for_skill'):
            # Check if item is unlocked using the item's built-in method
            if hasattr(item, 'is_unlocked'):
                if not item.is_unlocked(character, ignore_gear_requirements=True):
                    excluded_count += 1
                    continue
            
            all_items.append(item)
    
    print(f"Found {len(all_items)} items to choose from ({excluded_count} locked)")
    
    # For each slot, pick best item
    gear_slots = ['head', 'cape', 'back', 'chest', 'primary', 'secondary',
                  'hands', 'legs', 'neck', 'feet', 'ring1', 'ring2']
    
    # Check activity requirements using unified keyword_counts
    # Get required keywords from activity
    required_keywords = activity.requirements.get('keyword_counts', {})
    
    # Track how many of each keyword we've added so far
    current_keyword_counts = {kw: 0 for kw in required_keywords.keys()}
    
    for slot in gear_slots:
        item_slot = 'ring' if slot in ['ring1', 'ring2'] else slot
        
        # Check which keywords we still need
        needed_keywords = {kw for kw, required in required_keywords.items() 
                          if current_keyword_counts[kw] < required}
        
        best_item = None
        best_metric = float('inf') if not SORTING_PRIORITY[0].is_reverse else float('-inf')
        
        for item in all_items:
            if not hasattr(item, 'slot') or item.slot != item_slot:
                continue
            
            # Check which needed keywords this item has
            item_keywords = {kw for kw in needed_keywords if item_has_keyword(item, kw)}
            
            # Skip if we need keywords but this item doesn't have any
            if needed_keywords and not item_keywords:
                continue
            
            # Test this item in the slot
            test_gearset = gearset.copy()
            test_gearset[slot] = item
            
            # Only check UUID/keyword constraints during greedy (not activity requirements)
            if not is_gearset_valid(test_gearset, character, activity=None, check_requirements=False):
                continue
            
            metrics, _ = calculate_gearset_metrics(test_gearset, activity, character)
            metric_value = metrics[SORTING_PRIORITY[0].metric_key]
            
            # Boost items that have needed keywords
            if item_keywords:
                if SORTING_PRIORITY[0].is_reverse:
                    metric_value = metric_value * 1.5  # Boost for maximize metrics
                else:
                    metric_value = metric_value * 0.5  # Boost for minimize metrics (lower is better)
            
            if SORTING_PRIORITY[0].is_reverse:
                if metric_value > best_metric:
                    best_metric = metric_value
                    best_item = item
            else:
                if metric_value < best_metric:
                    best_metric = metric_value
                    best_item = item
        
        gearset[slot] = best_item
        
        # Update keyword counts
        if best_item:
            for kw in required_keywords.keys():
                if item_has_keyword(best_item, kw):
                    current_keyword_counts[kw] += 1
        
        if best_item:
            print(f"  {slot}: {best_item.name}")
        else:
            print(f"  {slot}: None (no valid items found)")
    
    # Verify we have enough of each required keyword
    for kw, required in required_keywords.items():
        if required > 0:
            print(f"\n{kw}: {current_keyword_counts[kw]}/{required} required")
    
    # Add tools - fill them greedily too
    tool_slots = character.get_tool_slots()
    print(f"\nAdding {tool_slots} tool slots...")
    
    for i in range(tool_slots):
        slot = f'tool{i}'
        
        # Check which keywords we still need
        needed_keywords = {kw for kw, required in required_keywords.items() 
                          if current_keyword_counts[kw] < required}
        
        best_tool = None
        best_metric = float('inf') if not SORTING_PRIORITY[0].is_reverse else float('-inf')
        
        for item in all_items:
            if not hasattr(item, 'slot') or item.slot != 'tools':
                continue
            
            # Check which needed keywords this item has
            item_keywords = {kw for kw in needed_keywords if item_has_keyword(item, kw)}
            
            # Skip if we need keywords but this item doesn't have any
            if needed_keywords and not item_keywords:
                continue
            
            # Test this tool
            test_gearset = gearset.copy()
            test_gearset[slot] = item
            
            # Validate
            if not is_gearset_valid(test_gearset, character, activity=None, check_requirements=False):
                continue
            
            metrics, _ = calculate_gearset_metrics(test_gearset, activity, character)
            metric_value = metrics[SORTING_PRIORITY[0].metric_key]
            
            # Boost items that have needed keywords
            if item_keywords:
                if SORTING_PRIORITY[0].is_reverse:
                    metric_value = metric_value * 1.5  # Boost for maximize metrics
                else:
                    metric_value = metric_value * 0.5  # Boost for minimize metrics (lower is better)
            
            if SORTING_PRIORITY[0].is_reverse:
                if metric_value > best_metric:
                    best_metric = metric_value
                    best_tool = item
            else:
                if metric_value < best_metric:
                    best_metric = metric_value
                    best_tool = item
        
        gearset[slot] = best_tool
        
        # Update keyword counts
        if best_tool:
            for kw in required_keywords.keys():
                if item_has_keyword(best_tool, kw):
                    current_keyword_counts[kw] += 1
        
        if best_tool:
            print(f"  {slot}: {best_tool.name}")
        else:
            print(f"  {slot}: None (no valid tools found)")
    
    print(f"\nInitial gearset has {sum(1 for item in gearset.values() if item)} items")
    return gearset

# ============================================================================
# LOCAL SEARCH REFINEMENT
# ============================================================================

def local_search_refine(initial_gearset: dict, activity, character, max_iterations: int) -> dict:
    """
    Refine gearset using local search (hill climbing).
    
    Strategy:
    1. For each slot, try swapping with every other item
    2. If better, keep the swap
    3. Repeat until no improvements found
    
    Returns:
        Refined gearset dict
    """
    print(f"\n{'='*70}")
    print(f"LOCAL SEARCH REFINEMENT")
    print(f"{'='*70}")
    
    current_gearset = initial_gearset.copy()
    metric_key = SORTING_PRIORITY[0].metric_key
    
    # Calculate initial metrics
    current_metrics, current_stats = calculate_gearset_metrics(current_gearset, activity, character)
    current_value = current_metrics[metric_key]
    
    print(f"Initial {metric_key}: {current_value:.4f}")
    
    # Get all items (filter by unlock status)
    all_items = []
    for item, qty in character.items.items():
        if qty > 0 and hasattr(item, 'get_stats_for_skill'):
            # Check if item is unlocked using the item's built-in method
            if hasattr(item, 'is_unlocked'):
                if not item.is_unlocked(character, ignore_gear_requirements=True):
                    continue
            
            all_items.append(item)
    
    for iteration in range(max_iterations):
        if VERBOSE:
            print(f"\nIteration {iteration + 1}:")
        improved = False
        best_swap = None
        best_value = current_value
        best_gearset = None
        best_gearset_metrics = current_metrics
        best_gearset_stats = None
        
        swaps_tested = 0
        swaps_valid = 0
        
        # Try swapping each slot
        for slot in current_gearset.keys():
            current_item = current_gearset[slot]
            
            # Debug for slots
            if VERBOSE and slot in SLOTS_TO_TEST:
                print(f"\n  Testing {slot} (current: {current_item.name if current_item else 'None'})...")
            
            # Determine slot type
            if slot.startswith('ring'):
                item_slot = 'ring'
            elif slot.startswith('tool'):
                item_slot = 'tools'
            else:
                item_slot = slot
            
            # Try every other item in this slot
            legs_items_tested = 0
            valid_items_for_slot = 0
            better_items_found = 0
            for new_item in all_items:
                swaps_tested += 1
                
                if not hasattr(new_item, 'slot') or new_item.slot != item_slot:
                    continue
                
                if new_item == current_item:
                    continue
                
                if VERBOSE and slot in SLOTS_TO_TEST:
                    valid_items_for_slot += 1
                    if valid_items_for_slot <= 10:
                        print(f"    Testing {new_item.name}...")
                
                # Create test gearset
                test_gearset = current_gearset.copy()
                test_gearset[slot] = new_item
                
                # Validate (check requirements only on complete gearsets)
                if not is_gearset_valid(test_gearset, character, activity, check_requirements=True):
                    if VERBOSE and slot in SLOTS_TO_TEST and valid_items_for_slot <= 10:
                        print(f"      -> INVALID (constraint violation)")
                    continue
                
                swaps_valid += 1
                
                # Calculate metrics
                test_metrics, test_stats = calculate_gearset_metrics(test_gearset, activity, character)
                test_value = test_metrics[metric_key]
                
                if VERBOSE and slot in SLOTS_TO_TEST and valid_items_for_slot <= 10:
                    print(f"      -> Valid! Metric: {test_value:.4f} (current best: {best_value:.4f})")
                
                # Multi-level comparison (primary, secondary, tertiary)
                # Note: Using inline logic for performance (method calls are 10x slower)
                is_better = Sorting.is_better(test_metrics, best_gearset_metrics, SORTING_PRIORITY)
                
                if is_better:
                    best_value = test_value
                    best_swap = (slot, current_item, new_item)
                    best_gearset = test_gearset.copy()
                    best_gearset_metrics = test_metrics
                    best_gearset_stats = test_stats
                    improved = True
        
        if VERBOSE:
            print(f"  Tested {swaps_tested} swaps, {swaps_valid} valid")
        
        if improved:
            slot, old_item, new_item = best_swap
            old_name = old_item.name if old_item else "None"
            if VERBOSE:
                print(f"  Improved! Swapped {slot}: {old_name} → {new_item.name}")
                for sorting in SORTING_PRIORITY:
                    metric_key = sorting.metric_key
                    val_a = current_metrics[metric_key]
                    val_b = best_gearset_metrics[metric_key]
                    print(f"  {sorting.display_name}: {val_a:.2f} → {val_b:.2f} (Δ {val_b - val_a:+.2f})")
                    if val_a != val_b:
                        break
                
            current_gearset = best_gearset
            current_value = best_value
            current_metrics = best_gearset_metrics
            current_gearset_stats = best_gearset_stats
        else:
            if VERBOSE:
                print(f"  No improvements found. Converged!")
            break
    
    print(f"\nFinal {metric_key}: {current_value:.4f}")
    return current_gearset

# ============================================================================
# MAIN
# ============================================================================

if __name__ == '__main__':
    character = get_character()
    
    print(f"\n{'='*70}")
    print(f"V11: GREEDY + LOCAL SEARCH")
    print(f"{'='*70}")
    print(f"Activity: {ACTIVITY.name}")
    
    if TARGET_ITEM is not None:
        target_name = get_target_name(TARGET_ITEM)
        print(f"Target: {target_name}")
        if is_fine_material_target(TARGET_ITEM):
            print(f"Optimizing for: Steps per fine material")
        else:
            print(f"Optimizing for: Steps per item drop")
    else:
        priority_names = ' > '.join(s.name for s in SORTING_PRIORITY)
        print(f"Optimizing: {priority_names}")
    
    # Step 1: Get initial solution (greedy)
    start_time = time.time()
    initial_gearset = get_greedy_initial_solution(ACTIVITY, character)
    greedy_time = time.time() - start_time
    
    initial_metrics, initial_stats = calculate_gearset_metrics(initial_gearset, ACTIVITY, character)
    metric_key = SORTING_PRIORITY[0].metric_key
    
    print(f"\nGreedy solution found in {greedy_time:.2f}s")
    print(f"Initial {metric_key}: {initial_metrics[metric_key]:.4f}")
    
    # Step 2: Refine using local search
    start_time = time.time()
    final_gearset = local_search_refine(initial_gearset, ACTIVITY, character, MAX_ITERATIONS)
    refine_time = time.time() - start_time
    
    print(f"\nLocal search completed in {refine_time:.2f}s")
    
    # Step 3: Print final result
    final_metrics, final_stats = calculate_gearset_metrics(final_gearset, ACTIVITY, character, True)
    
    print(f"\n{'='*70}")
    print(f"FINAL RESULT")
    print(f"{'='*70}")
    
    # All metrics are already calculated in final_metrics
    print(f"\nMetrics:")
    print(f"  Steps per action (displayed): {final_metrics['current_steps']}")
    print(f"  Steps per action (expected): {final_metrics['expected_steps_per_action']}")
    print(f"  Steps per reward roll: {final_metrics['steps_per_reward_roll']:.2f}")
    print(f"  XP per action (displayed): {final_metrics['primary_xp_per_action']:.2f}")
    print(f"  Primary XP per step: {final_metrics['primary_xp_per_step']:.4f}")
    
    # Show secondary skill XP if any
    if 'secondary_xp_per_step' in final_metrics and final_metrics['secondary_xp_per_step']:
        print(f"\n  Secondary XP per step:")
        for skill, xp_per_step in final_metrics['secondary_xp_per_step'].items():
            print(f"    {skill}: {xp_per_step:.4f}")
    
    # If targeting specific item, show that too
    if TARGET_ITEM is not None:
        target_name = get_target_name(TARGET_ITEM)
        print(f"\n  Target Item: {target_name}")
        if is_fine_material_target(TARGET_ITEM):
            print(f"  Steps per fine material: {final_metrics['steps_per_reward_roll']:.1f}")
        else:
            print(f"  Steps per item drop: {final_metrics['steps_per_reward_roll']:.1f}")
    
    # Show ALL stats (gear + level bonus + collectibles)
    print(f"\nAll Stats (gear + level + collectibles):")
    
    # Sort stats for consistent display
    stat_display_order = [
        'work_efficiency', 'double_action', 'double_rewards', 
        'steps_add', 'steps_percent',
        'bonus_xp_percent', 'bonus_xp_add',
        'no_materials_consumed', 'quality_outcome',
        'fine_material_finding', 'find_collectibles', 'find_gems', 'find_bird_nests',
        'chest_finding', 'inventory_space'
    ]
    
    # Display known stats in order
    for stat_name in stat_display_order:
        if stat_name in final_stats and final_stats[stat_name] != 0:
            value = final_stats[stat_name]
            # Format based on stat type
            if stat_name in ['steps_add', 'bonus_xp_add', 'inventory_space']:
                print(f"  {stat_name}: {int(value)}")
            elif stat_name == 'quality_outcome':
                print(f"  {stat_name}: {value:.0f}")
            else:
                print(f"  {stat_name}: {value * 100:.1f}%")
    
    # Display any other stats not in the order list
    for stat_name, value in sorted(final_stats.items()):
        if stat_name not in stat_display_order and value != 0:
            if isinstance(value, float) and abs(value) < 1:
                print(f"  {stat_name}: {value * 100:.1f}%")
            else:
                print(f"  {stat_name}: {value}")
    
    print(f"\nItems:")
    for slot, item in sorted(final_gearset.items()):
        if item:
            print(f"  {slot}: {item.name}")
    
    # Generate export
    export = encode_gearset(final_gearset)
    print(f"\n{'='*70}")
    print(f"GEARSET EXPORT")
    print(f"{'='*70}")
    print(export)
