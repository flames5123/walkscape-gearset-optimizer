#!/usr/bin/env python3
"""
Item catalog builder for Walkscape UI.

Organizes all items into categories for UI display:
- Collectibles
- Consumables (by skill)
- Materials
- Loot (achievement rewards, activity drops, faction rewards, shop items, chests)
- Crafted (by keyword)
- Pets

Auto-generated by scrape_equipment.py, scrape_materials.py, scrape_consumables.py, etc.
"""

from typing import Dict, List, Optional, Set, Tuple
from collections import defaultdict

# Import everything from walkscape_constants which handles circular imports correctly
from util.walkscape_constants import (
    Item, Material, Consumable, Container, Activity,
    Collectible, COLLECTIBLES_BY_NAME
)

# Helper function to get icon path
def get_icon_path(item_name: str, item_type: str = 'equipment') -> str:
    """Get icon path for an item."""
    # Sanitize name for filename - keep hyphens and apostrophes
    filename = item_name.replace(' ', '_').lower() + '.svg'
    
    # Check if this is a pet egg (ends with " egg")
    if item_name.endswith(' egg'):
        # Check if it's actually a pet egg by trying to import
        try:
            from util.autogenerated.pets import EGGS_BY_NAME
            if item_name in EGGS_BY_NAME:
                return f"icons/items/pet_eggs/{filename}"
        except:
            pass
    
    # Determine subdirectory based on type
    if item_type == 'container':
        subdir = 'containers'
    elif item_type == 'consumable':
        subdir = 'consumables'
    elif item_type == 'collectible':
        subdir = 'collectibles'
    elif item_type == 'material':
        subdir = 'materials'
    else:
        subdir = 'equipment'
    
    # Return path - let browser handle 404s
    return f"icons/items/{subdir}/{filename}"


class ItemCatalog:
    """Organizes all items into categories for UI display"""
    
    def __init__(self):
        self._build_catalog()
    
    def _build_catalog(self):
        """Build categorized item lists from equipment, materials, etc."""
        self.categories = {
            'collectibles': self._get_collectibles(),
            'consumables': self._get_consumables_by_skill(),
            'loot': {
                'ap_rewards': [],  # TODO: Need to pull from AP track
                'achievement_rewards': self._get_achievement_items(),
                'activity_drops': self._get_activity_drops(),
                'faction_rewards': self._get_faction_items(),
                'shop_items': self._get_shop_items(),
            },
            'crafted': self._get_crafted_by_keyword(),
            'chests': self._get_chests_with_contents(),
            'pets': [],  # TODO: Not in export yet
            'materials': self._get_all_materials(),
            'all_equipment': self._get_all_equipment(),  # All equipment items for catalog API
        }
    
    def _get_collectibles(self) -> List[Dict]:
        """Get all collectibles"""
        items = []
        for collectible in COLLECTIBLES_BY_NAME.values():
            items.append({
                'id': self._name_to_id(collectible.name),
                'name': collectible.name,
                'type': 'collectible',
                'rarity': 'common',  # Collectibles don't have rarity
                'keywords': [],
                'stats': collectible._stats,
                'icon_path': f"/assets/{get_icon_path(collectible.name, 'collectible')}",
            })
        return sorted(items, key=lambda x: x['name'].lower())
    
    def _get_consumables_by_skill(self) -> Dict[str, List[Dict]]:
        """Organize consumables by skill affinity, combining normal and fine versions"""
        by_skill = defaultdict(list)
        consumables_dict = {}  # (skill, base_id) -> consumable entry
        
        # Get all consumables (they are uppercase class attributes)
        for attr_name in dir(Consumable):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            consumable = getattr(Consumable, attr_name)
            # Duck typing: check if it has the attributes we need
            if not hasattr(consumable, 'name') or not hasattr(consumable, '_stats'):
                continue
            
            # Skip memospheres
            if 'memosphere' in consumable.name.lower():
                continue
            
            # Determine skill affinity from stats
            skill_affinity = self._get_consumable_skill(consumable)
            
            # Check if this is a fine version
            is_fine = consumable.name.endswith('(Fine)')
            base_name = consumable.name.replace(' (Fine)', '')
            base_id = self._name_to_id(base_name)
            
            # Create key for grouping by skill and base name
            key = (skill_affinity, base_id)
            
            # Create or update entry for this base consumable
            if key not in consumables_dict:
                consumables_dict[key] = {
                    'id': base_id,
                    'name': base_name,
                    'type': 'consumable',
                    'slot': 'consumable',
                    'has_fine': False,
                    'skill': skill_affinity,
                    'duration': consumable.duration if not is_fine else None,
                    'duration_fine': consumable.duration if is_fine else None,
                    'value': consumable.value if not is_fine else None,
                    'value_fine': consumable.value if is_fine else None,
                    'keywords': consumable.keywords,
                    'stats': consumable._stats if not is_fine else None,
                    'stats_fine': consumable._stats if is_fine else None,
                    'rarity': 'common',
                    'icon_path': f"/assets/{get_icon_path(base_name, 'consumable')}",
                }
            
            # Update with fine info if this is the fine version
            if is_fine:
                consumables_dict[key]['has_fine'] = True
                consumables_dict[key]['duration_fine'] = consumable.duration
                consumables_dict[key]['value_fine'] = consumable.value
                consumables_dict[key]['stats_fine'] = consumable._stats
            else:
                consumables_dict[key]['duration'] = consumable.duration
                consumables_dict[key]['value'] = consumable.value
                consumables_dict[key]['stats'] = consumable._stats
        
        # Group by skill
        for (skill_affinity, _), consumable_entry in consumables_dict.items():
            by_skill[skill_affinity].append(consumable_entry)
        
        # Sort items within each skill
        result = {}
        for skill, items_list in by_skill.items():
            result[skill] = sorted(items_list, key=lambda x: x['name'].lower())
        
        return result
    
    def _get_consumable_skill(self, consumable) -> str:
        """Determine skill affinity from consumable stats"""
        # Check stats structure: {skill: {location: {stat: value}}}
        if not consumable._stats:
            return 'Global'
        
        # Get all skills from stats
        skills = [skill for skill in consumable._stats.keys() if skill != 'global']
        
        if not skills:
            return 'Global'
        
        # Return first skill (most consumables have one skill)
        skill = skills[0]
        
        # Map skill names to display names
        skill_map = {
            'agility': 'Agility',
            'carpentry': 'Carpentry',
            'cooking': 'Cooking',
            'crafting': 'Crafting',
            'fishing': 'Fishing',
            'foraging': 'Foraging',
            'mining': 'Mining',
            'smithing': 'Smithing',
            'trinketry': 'Trinketry',
            'woodcutting': 'Woodcutting',
            'traveling': 'Traveling',  # Note: "Traveling" not "Travel"
        }
        
        return skill_map.get(skill.lower(), skill.capitalize())
    
    def _get_all_materials(self) -> List[Dict]:
        """Get all materials, combining normal and fine versions"""
        materials_dict = {}  # base_name -> material entry
        
        for attr_name in dir(Material):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            material = getattr(Material, attr_name)
            # Duck typing: check if it has the attributes we need
            if not hasattr(material, 'name') or not hasattr(material, 'value'):
                continue
            
            # Check if this is a fine version
            is_fine = material.name.endswith('(Fine)')
            base_name = material.name.replace(' (Fine)', '')
            base_id = self._name_to_id(base_name)
            
            # Create or update entry for this base material
            if base_id not in materials_dict:
                materials_dict[base_id] = {
                    'id': base_id,
                    'name': base_name,
                    'type': 'material',
                    'has_fine': False,
                    'value': material.value if not is_fine else None,
                    'value_fine': material.value if is_fine else None,
                    'keywords': material.keywords,
                    'rarity': 'common',
                    'icon_path': f"/assets/{get_icon_path(base_name, 'material')}",
                }
            
            # Update with fine info if this is the fine version
            if is_fine:
                materials_dict[base_id]['has_fine'] = True
                materials_dict[base_id]['value_fine'] = material.value
            else:
                materials_dict[base_id]['value'] = material.value
        
        # Convert to list and sort
        items = list(materials_dict.values())
        return sorted(items, key=lambda x: x['name'].lower())
    
    def _get_achievement_items(self) -> Dict[str, List[Dict]]:
        """Get items organized by achievement keyword"""
        by_keyword = defaultdict(list)
        
        for attr_name in dir(Item):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            item = getattr(Item, attr_name)
            # Duck typing: check if it has the attributes we need
            if not hasattr(item, 'name') or not hasattr(item, 'keywords'):
                continue
            
            # Check if item has "achievement reward" keyword
            keywords = getattr(item, 'keywords', [])
            if not any('achievement' in kw.lower() for kw in keywords):
                continue
            
            # Find other keywords to categorize by
            for keyword in keywords:
                if 'achievement' not in keyword.lower():
                    item_dict = self._item_to_dict(item)
                    by_keyword[keyword].append(item_dict)
        
        # Sort items within each keyword
        for keyword in by_keyword:
            by_keyword[keyword] = self._sort_items(by_keyword[keyword])
        
        return dict(by_keyword)
    
    def _get_activity_drops(self) -> List[Dict]:
        """Get all items that drop from activities"""
        dropped_items = set()
        
        # Iterate through all activities
        for attr_name in dir(Activity):
            if attr_name.startswith('_') or attr_name.isupper():
                continue
            
            activity = getattr(Activity, attr_name)
            if not hasattr(activity, 'drop_table'):
                continue
            
            # Add items from drop table
            for drop in activity.drop_table:
                dropped_items.add(drop.item_name)
            
            # Add items from secondary drop table
            if hasattr(activity, 'secondary_drop_table'):
                for drop in activity.secondary_drop_table:
                    dropped_items.add(drop.item_name)
        
        # Convert item names to item dicts
        items = []
        for item_name in dropped_items:
            item = self._find_item_by_name(item_name)
            if item:
                items.append(item)
        
        return self._sort_items(items)
    
    def _get_faction_items(self) -> Dict[str, List[Dict]]:
        """Get items organized by faction keyword"""
        by_faction = defaultdict(list)
        
        factions = ['Jarvonia', 'Erdwise', 'Trellin', 'Halfling Rebels', 'Syrenthia', 'Herbert']
        
        for attr_name in dir(Item):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            item = getattr(Item, attr_name)
            # Duck typing: check if it has the attributes we need
            if not hasattr(item, 'name') or not hasattr(item, 'keywords'):
                continue
            
            keywords = getattr(item, 'keywords', [])
            
            # Check if item has faction keyword
            for faction in factions:
                if any(faction.lower() in kw.lower() for kw in keywords):
                    item_dict = self._item_to_dict(item)
                    by_faction[faction].append(item_dict)
        
        # Sort items within each faction
        for faction in by_faction:
            by_faction[faction] = self._sort_items(by_faction[faction])
        
        return dict(by_faction)
    
    def _get_shop_items(self) -> List[Dict]:
        """Get non-crafted items not in chests (shop items)"""
        # TODO: Need to scrape shops
        # For now, return items that are not crafted and not in chests
        shop_items = []
        chest_items = set()
        
        # Get all items from chests
        for attr_name in dir(Container):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            container = getattr(Container, attr_name)
            if not hasattr(container, 'get_all_drops'):
                continue
            
            for drop in container.get_all_drops():
                chest_items.add(drop.item_name)
        
        # Get all non-crafted items
        for attr_name in dir(Item):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            item = getattr(Item, attr_name)
            # Skip crafted items (they have NORMAL, GOOD quality attributes)
            if hasattr(item, 'NORMAL') and hasattr(item, 'GOOD'):
                continue
            
            # Duck typing: check if it has the attributes we need
            if not hasattr(item, 'name') or not hasattr(item, 'uuid'):
                continue
            
            # Skip if in chests
            if item.name in chest_items:
                continue
            
            shop_items.append(self._item_to_dict(item))
        
        return self._sort_items(shop_items)
    
    def _get_chest_items(self) -> List[Dict]:
        """Get all containers (chests) with special ordering"""
        items = []
        
        # Special containers to put at top
        special_containers = ['Bird Nest', 'Coin Pouch', 'Gem Pouch']
        special_items = []
        regular_items = []
        
        for attr_name in dir(Container):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            container = getattr(Container, attr_name)
            if not hasattr(container, 'name'):
                continue
            
            item_dict = {
                'id': self._name_to_id(container.name),
                'name': container.name,
                'type': 'container',
                'rarity': 'common',  # Containers don't have rarity
                'keywords': ['Container'],
                'icon_path': f"/assets/{get_icon_path(container.name, 'container')}",
            }
            
            if container.name in special_containers:
                special_items.append(item_dict)
            else:
                regular_items.append(item_dict)
        
        # Sort special items by the order in special_containers
        special_items.sort(key=lambda x: special_containers.index(x['name']) if x['name'] in special_containers else 999)
        
        # Sort regular items alphabetically
        regular_items.sort(key=lambda x: x['name'].lower())
        
        return special_items + regular_items
    
    def _get_chests_with_contents(self) -> Dict[str, Dict]:
        """Get all chests with their contents (items that can drop from them)"""
        chests = {}
        
        # Chests to exclude
        excluded_chests = ['Bird Nest', 'Coin Pouch', 'Gem Pouch']
        
        for attr_name in dir(Container):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            container = getattr(Container, attr_name)
            if not hasattr(container, 'name'):
                continue
            
            # Skip excluded chests
            if container.name in excluded_chests:
                continue
            
            # Get all drops from this chest (excluding materials and coins)
            all_drops = container.get_all_drops()
            chest_contents = []
            
            for drop_entry in all_drops:
                # drop_entry is a DropEntry object with item_ref like "Material.BIRCH_LOGS" or "Item.TRAVELERS_KIT"
                if not hasattr(drop_entry, 'item_ref') or drop_entry.item_ref is None:
                    continue
                
                item_ref = drop_entry.item_ref
                
                # Skip materials
                if item_ref.startswith('Material.'):
                    continue
                
                # Parse item_ref to get the actual item
                # Format: "Item.TRAVELERS_KIT" or "Consumable.BEER"
                try:
                    parts = item_ref.split('.')
                    if len(parts) != 2:
                        continue
                    
                    class_name, attr_name = parts
                    
                    # Get the item from the appropriate class
                    if class_name == 'Item':
                        item = getattr(Item, attr_name, None)
                    elif class_name == 'Consumable':
                        item = getattr(Consumable, attr_name, None)
                    elif class_name == 'Container':
                        item = getattr(Container, attr_name, None)
                    else:
                        continue
                    
                    if item is None:
                        continue
                    
                    # Convert to dict
                    item_dict = self._item_to_dict(item)
                    if item_dict:  # Only add if conversion succeeded
                        chest_contents.append(item_dict)
                        
                except Exception as e:
                    print(f"Warning: Failed to parse item_ref '{item_ref}': {e}")
                    continue
            
            # Create chest entry
            chest_id = self._name_to_id(container.name)
            chests[chest_id] = {
                'id': chest_id,
                'name': container.name,
                'type': 'container',
                'icon_path': f"/assets/{get_icon_path(container.name, 'container')}",
                'contents': self._sort_items(chest_contents),
                'is_special': False  # No special chests anymore
            }
        
        return chests
    
    def _get_crafted_by_keyword(self) -> Dict[str, List[Dict]]:
        """Get crafted items organized by keyword"""
        by_keyword = defaultdict(list)
        
        # Define main crafted keywords
        main_keywords = [
            'Amulets', 'Chisels', 'Diving Gear', 'Fishing Tools', 'Hammers',
            'Hatchets', 'Pans', 'Pickaxes', 'Rings', 'Saws', 'Shields',
            'Sickles', 'Weapons', 'Wrenches'
        ]
        
        for attr_name in dir(Item):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            item = getattr(Item, attr_name)
            # Check if it's a crafted item (has NORMAL, GOOD, etc. quality attributes)
            if not (hasattr(item, 'NORMAL') and hasattr(item, 'GOOD')):
                continue
            
            keywords = getattr(item, 'keywords', [])
            
            # Find matching main keywords
            matched_keywords = []
            for keyword in keywords:
                for main_kw in main_keywords:
                    if main_kw.lower().rstrip('s') in keyword.lower():
                        matched_keywords.append(main_kw)
                        break
            
            # If no main keywords matched, put in "Misc. Crafted"
            if not matched_keywords:
                matched_keywords = ['Misc. Crafted']
            
            # Add to each matched keyword category
            item_dict = self._item_to_dict(item)
            for keyword in matched_keywords:
                by_keyword[keyword].append(item_dict)
        
        # Sort items within each keyword
        for keyword in by_keyword:
            by_keyword[keyword] = self._sort_items(by_keyword[keyword])
        
        return dict(by_keyword)
    
    def _item_to_dict(self, item) -> Dict:
        """Convert item object to dictionary"""
        # Handle AchievementItem (has _achievement_stats attribute)
        if hasattr(item, '_achievement_stats'):
            # Get stats for 0 AP (base stats)
            instance = item[0]
            
            # Build gated stats for achievement thresholds
            gated_stats = {}
            if hasattr(item, '_achievement_stats') and item._achievement_stats:
                gated_stats['achievement_points'] = {}
                for threshold, stats in item._achievement_stats.items():
                    if threshold > 0:  # Skip 0 AP (already in base stats)
                        gated_stats['achievement_points'][str(threshold)] = stats
                
                # Debug logging for Omni-Tool
                if item.name == "Omni-tool":
                    print(f"DEBUG: Omni-tool gated_stats: {gated_stats}")
            
            result = {
                'id': self._name_to_id(item.name),
                'name': item.name,
                'uuid': item.uuid,
                'type': 'achievement_item',
                'slot': item.slot,
                'value': item.value,
                'keywords': item.keywords,
                'rarity': getattr(item, 'rarity', 'legendary') or 'legendary',  # Use item's rarity if available
                'stats': instance._stats,
                'icon_path': f"/assets/{get_icon_path(item.name, 'equipment')}",
            }
            
            if gated_stats.get('achievement_points'):
                result['gated_stats'] = gated_stats
            
            return result
        
        # Handle CraftedItem (has NORMAL, GOOD quality attributes)
        if hasattr(item, 'NORMAL') and hasattr(item, 'GOOD'):
            # Get stats for each quality level
            stats_by_quality = {}
            for quality in ['NORMAL', 'GOOD', 'GREAT', 'EXCELLENT', 'PERFECT', 'ETERNAL']:
                if hasattr(item, quality):
                    quality_instance = getattr(item, quality)
                    quality_name = quality.capitalize()
                    stats_by_quality[quality_name] = quality_instance._stats
            
            # Get quality names from attributes
            qualities = list(stats_by_quality.keys())
            
            return {
                'id': self._name_to_id(item.name),
                'name': item.name,
                'uuid': item.uuid,
                'type': 'crafted_item',
                'slot': item.slot,
                'value': item.value,
                'keywords': item.keywords,
                'rarity': 'common',  # Base rarity, changes with quality
                'qualities': qualities,
                'stats_by_quality': stats_by_quality,  # Stats for each quality level
                'icon_path': f"/assets/{get_icon_path(item.name, 'equipment')}",
            }
        
        # Handle ItemInstance (regular item)
        if hasattr(item, 'uuid') and hasattr(item, '_stats'):
            item_dict = {
                'id': self._name_to_id(item.name),
                'name': item.name,
                'uuid': item.uuid,
                'type': 'item',
                'slot': item.slot,
                'value': item.value,
                'keywords': item.keywords,
                'rarity': getattr(item, 'rarity', 'common') or 'common',
                'stats': item._stats,
                'icon_path': f"/assets/{get_icon_path(item.name, 'equipment')}",
            }
            
            # Add gated_stats if present
            if hasattr(item, 'gated_stats'):
                item_dict['gated_stats'] = item.gated_stats
            
            return item_dict
        
        return {}
    
    def _find_item_by_name(self, name: str) -> Optional[Dict]:
        """Find item by name across all item types"""
        # Try equipment
        for attr_name in dir(Item):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            item = getattr(Item, attr_name)
            # Duck typing: check if it has the attributes we need
            if not hasattr(item, 'name') or not hasattr(item, 'uuid'):
                continue
            
            if item.name.lower() == name.lower():
                return self._item_to_dict(item)
        
        # Try materials
        for attr_name in dir(Material):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            material = getattr(Material, attr_name)
            # Duck typing: check if it has the attributes we need
            if not hasattr(material, 'name') or not hasattr(material, 'value'):
                continue
            
            if material.name.lower() == name.lower():
                is_fine = material.name.endswith('(Fine)')
                base_name = material.name.replace(' (Fine)', '')
                return {
                    'id': self._name_to_id(material.name),
                    'name': material.name,
                    'base_name': base_name,
                    'type': 'material',
                    'is_fine': is_fine,
                    'value': material.value,
                    'keywords': material.keywords,
                    'rarity': 'common',
                }
        
        return None
    
    def _sort_items(self, items: List[Dict]) -> List[Dict]:
        """Sort items by rarity then alphabetically"""
        rarity_order = {
            'common': 0,
            'uncommon': 1,
            'rare': 2,
            'epic': 3,
            'legendary': 4,
            'ethereal': 5,
        }
        
        return sorted(items, key=lambda x: (
            rarity_order.get(x.get('rarity', 'common').lower(), 0),
            x.get('name', '').lower()
        ))
    
    def _name_to_id(self, name: str) -> str:
        """Convert item name to ID (lowercase, underscores)"""
        return name.lower().replace(' ', '_').replace('(', '').replace(')', '').replace('-', '_').replace("'", '')
    
    def get_item_info(self, item_id: str) -> Optional[Dict]:
        """Get full item info by ID"""
        # Search through all categories
        for category_name, category_data in self.categories.items():
            if category_name == 'consumables':
                for skill, items in category_data.items():
                    for item in items:
                        if item['id'] == item_id:
                            return item
            elif category_name == 'loot':
                for subcategory, items in category_data.items():
                    if isinstance(items, dict):
                        for keyword, keyword_items in items.items():
                            for item in keyword_items:
                                if item['id'] == item_id:
                                    return item
                    else:
                        for item in items:
                            if item['id'] == item_id:
                                return item
            elif category_name == 'crafted':
                for keyword, items in category_data.items():
                    for item in items:
                        if item['id'] == item_id:
                            return item
            else:
                for item in category_data:
                    if item['id'] == item_id:
                        return item
        
        return None
    
    def get_categories(self) -> Dict:
        """Get all categories with item counts"""
        counts = {}
        
        # Collectibles
        counts['collectibles'] = len(self.categories['collectibles'])
        
        # Consumables (count all items across skills)
        consumables_count = sum(len(items) for items in self.categories['consumables'].values())
        counts['consumables'] = consumables_count
        
        # Materials
        counts['materials'] = len(self.categories['materials'])
        
        # Loot (count all subcategories)
        loot_count = 0
        for subcategory, items in self.categories['loot'].items():
            if isinstance(items, dict):
                loot_count += sum(len(keyword_items) for keyword_items in items.values())
            else:
                loot_count += len(items)
        counts['loot'] = loot_count
        
        # Crafted (count all items across keywords)
        crafted_count = sum(len(items) for items in self.categories['crafted'].values())
        counts['crafted'] = crafted_count
        
        # Pets
        counts['pets'] = len(self.categories['pets'])
        
        return counts

    
    def _get_all_equipment(self) -> List[Dict]:
        """Get ALL equipment items (for catalog API)"""
        items = []
        
        for attr_name in dir(Item):
            if attr_name.startswith('_'):
                continue
            
            # Skip methods (lowercase)
            if not attr_name.isupper():
                continue
            
            item = getattr(Item, attr_name)
            
            # Duck typing: check if it has the attributes we need
            if not hasattr(item, 'name') or not hasattr(item, 'uuid'):
                continue
            
            item_dict = self._item_to_dict(item)
            if item_dict:  # Only add if conversion succeeded
                items.append(item_dict)
        
        return self._sort_items(items)
