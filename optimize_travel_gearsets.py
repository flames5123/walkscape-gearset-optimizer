#!/usr/bin/env python3
"""
Optimize gearsets for travel efficiency using greedy + local search.

Finds best gear combinations to minimize steps for traveling between locations.
Uses the proven greedy initialization + local search refinement algorithm.
"""

# Standard library imports
import math
import time
from typing import Dict, List, Optional, Tuple

# Local imports
from my_config import get_character
from util.gearset_utils import aggregate_gearset_stats
from util.autogenerated.equipment import Item
from util.autogenerated.routes import RAW_ROUTES
from util.gearset_utils import encode_gearset, Gearset
from util.greedy_local_search import (
    optimize_gearset_greedy_local_search,
    create_multi_level_comparator,
    prepare_items_by_slot
)
from util.optimization_utils import filter_items_by_quality, filter_ignored_items
from util.walkscape_constants import *

# ============================================================================
# CONFIGURATION
# ============================================================================

# Array of sorting priorities (first = primary, second = tiebreaker, etc.)
SORTING_PRIORITY = [
    Sorting.TOTAL_STEPS,                # Primary: minimize total steps
    Sorting.XP_PER_STEP,                # Tiebreaker 1: maximize XP per step
]

# Option 1: Specify exact routes to optimize
TEST_ROUTES = [
    (Location.KALLAHEIM, Location.FRUSENHOLM),
    # Add more specific routes here
]

# Display options
VERBOSE = True  # Enable debug output
MAX_ITERATIONS = 100

# Items to ignore
IGNORED_ITEMS = {
    Item.HERBERTS_BOOTS, Item.HERBERTS_CAPE, Item.HERBERTS_HAT,
    Item.HERBERTS_SHIRT, Item.HERBERTS_PANTS,
    Item.RUSTY_DIVING_HELMET, Item.RUSTY_DIVING_LEGGINGS, Item.RUSTY_DIVING_TORSO
}

# Locations to optimize travel for
# The optimizer will find all routes connecting any of these locations
TEST_LOCATIONS = [
    # Jarvonia
    Location.KALLAHEIM,
    # Location.PORT_SKILDAR,
    # Location.FRUSENHOLM,
    # Location.CENTAHAM,
    # Location.COLDINGTON,
    # Location.AZURAZERA,
    # Location.CASBRANT_FIELDS,
    # Location.NURTURING_NOOK_SPRINGS,
    # Location.BARBANTOK,
    # Location.NOMAD_WOODS,
    # Location.FORT_OF_PERMAFROST,
    # Location.HORN_OF_RESPITE,
    # Location.NOISELESS_PASS,
    # Location.FROSTBITE_MOUNTAIN,
    # Location.NORSACK_PLAINS,
    # Location.WINTER_WAVES_GLACIER,
    Location.DISENCHANTED_FOREST,
    # Location.PIT_OF_PITTANCE,
    # Location.BEACH_OF_WOES,
    # Location.BLACK_EYE_PEAK,
    # Location.SANGUINE_HILLS,
    # Location.WINTERS_END,
    
    # # Syrenthia (Underwater)
    # Location.CASBRANTS_GRAVE,
    # Location.VASTALUME,
    # Location.DARKTIDE_TRENCH,
    # Location.ELARAS_LAGOON,
    # Location.KELP_FOREST,
    # Location.UNDERWATER_CAVE,
    
    # # Trellin
    # Location.SALSFIRTH,
    # Location.EVERHAVEN,
    # Location.FARSAND_COAST,
    # Location.MANGROVE_FOREST,
    # Location.GRANFIDDICH,
    # Location.GRANFIDDICH_SHORES,
    # Location.WARRENFIELD,
    
    # # Erdwise
    # Location.BLACKSPELL_PORT,
    # Location.BILGEMONT_PORT,
    # Location.OLD_ARENA_RUINS,
    # Location.RED_COAST,
    
    # # # Halfling Rebels
    # Location.WITCHED_WOODS,
    # Location.BOG_TOP,
    # Location.BOG_BOTTOM,
    # Location.HALFLING_CAMPGROUNDS,
    # Location.HALFMAW_HIDEOUT,
    
    # # Other
    # Location.BLACKRANE,
    # Location.BLACKWATER_FIELDS,
    # Location.STALKING_YEW_WOODS,
    # Location.KILDOME_CROSS,
    # Location.WRAITHWATER,
    # Location.TENDON_WET_FIELDS,
    # Location.MYRIADIAN_ARC,
    # Location.CROWN_OF_CINDERS,
]

def get_test_routes():
    """Generate routes connecting TEST_LOCATIONS."""
    return [
        (start, end) for (start, end) in RAW_ROUTES.keys()
        if start in TEST_LOCATIONS and end in TEST_LOCATIONS
    ]

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def calculate_route_steps(route: Tuple, stats: Dict[str, float], character) -> int:
    """Calculate steps for a single route with given stats."""
    route_info = RAW_ROUTES.get(route)
    if not route_info:
        return float('inf')
    
    base_distance = route_info['distance']
    
    # Apply travel formula
    agility_level = character.get_skill_level('agility')
    level_we = (agility_level - 1) * 0.005
    total_we = level_we + stats.get('work_efficiency', 0.0)
    
    eff = 1.00 + total_we
    adj = (base_distance / eff) * (1 - stats.get('steps_percent', 0.0))
    rounded_total = math.ceil(adj)
    steps_per_node = rounded_total / 10 + stats.get('steps_add', 0)
    steps_per_node = max(10, math.ceil(steps_per_node))
    expected_paid_nodes = 10 / (1 + stats.get('double_action', 0.0))
    total_steps = math.ceil(expected_paid_nodes * steps_per_node)
    
    return total_steps

def meets_route_requirements(gearset_dict: dict, route: Tuple, character) -> bool:
    """Check if gearset meets route requirements."""
    route_info = RAW_ROUTES.get(route)
    if not route_info:
        return True
    
    items = [item for item in gearset_dict.values() if item is not None]
    
    # Handle keyword_counts format (new format)
    if 'keyword_counts' in route_info:
        keyword_counts = route_info['keyword_counts']
        
        for keyword, required_count in keyword_counts.items():
            if required_count <= 0:
                continue
            
            # Count items with this keyword
            count = sum(
                1 for item in items
                if hasattr(item, 'keywords') and
                any(keyword.lower() in kw.lower() for kw in item.keywords)
            )
            
            if count < required_count:
                return False
        
        return True
    
    # Handle legacy 'requires' format (backward compatibility)
    if 'requires' not in route_info:
        return True
    
    requirement = route_info['requires']
    
    # Handle tuple requirements (collectible, ability)
    if isinstance(requirement, tuple):
        req_type, req_value = requirement
        
        if req_type == 'collectible':
            # Check if character has collectible
            return True
        elif req_type == 'ability':
            # Check if character has ability
            return True
    
    # Handle legacy string requirements
    elif isinstance(requirement, str):
        if requirement == 'skis':
            return any(
                hasattr(item, 'keywords') and
                any('skis' in kw.lower() for kw in item.keywords)
                for item in items
            )
        elif requirement == 'diving_gear':
            diving_count = sum(
                1 for item in items
                if hasattr(item, 'keywords') and
                any('diving gear' in kw.lower() for kw in item.keywords)
            )
            return diving_count >= 3
        elif '2_light_sources' in requirement:
            light_count = len(set(
                item.uuid for item in items
                if hasattr(item, 'keywords') and
                any('light source' in kw.lower() for kw in item.keywords)
            ))
            return light_count >= 2
        elif '3_light_sources' in requirement:
            light_count = len(set(
                item.uuid for item in items
                if hasattr(item, 'keywords') and
                any('light source' in kw.lower() for kw in item.keywords)
            ))
            return light_count >= 3
    
    return True

def has_travel_stats(item, location, character) -> bool:
    """Check if item has any travel-relevant stats (or no negative stats)."""
    # Use 'travel' skill which combines both 'agility' and 'traveling' skills
    stats = item.get_stats_for_skill('travel', location=location, character=character)
    
    travel_stats = {
        'work_efficiency', 'double_action', 'steps_add', 'steps_percent'
    }
    
    # Include items with positive travel stats OR items with no stats at all
    # (items with no stats are neutral and better than items with negative stats)
    has_any_stat = any(stats.get(stat, 0) != 0 for stat in travel_stats)
    has_positive_we = stats.get('work_efficiency', 0) >= 0
    
    # Include if: has positive/neutral WE, or has other travel stats
    return not has_any_stat or has_positive_we or any(stats.get(stat, 0) > 0 for stat in ['double_action', 'steps_percent'] if stat != 'work_efficiency')

# ============================================================================
# SCORING FUNCTIONS
# ============================================================================

def calculate_travel_metrics(
    gearset_dict: dict,
    routes: List[Tuple],
    character
) -> Tuple[Dict[str, float], Dict[str, float]]:
    """
    Calculate metrics for a travel gearset (like activity/craft optimizer pattern).
    
    Returns:
        Tuple of (metrics_dict, stats_dict)
    """
    total_steps = 0
    valid_routes = 0
    all_stats = {}
    
    for route in routes:
        # Get stats for starting location using 'travel' skill (combines agility + traveling)
        start_location = route[0]
        items = [item for item in gearset_dict.values() if item is not None]
        
        # Use 'travel' which automatically combines agility and traveling stats
        stats = aggregate_gearset_stats(
            items=items,
            skill='travel',
            location=start_location,
            character=character,
            include_level_bonus=True,
            include_collectibles=True
        )
        
        # Calculate steps for this route
        steps = calculate_route_steps(route, stats, character)
        total_steps += steps
        valid_routes += 1
        
        # Store stats from first route for display
        if not all_stats:
            all_stats = stats
    
    if valid_routes == 0:
        return {'steps_for_target': float('inf'), 'total_steps': float('inf')}, {}
    
    avg_steps = total_steps / valid_routes
    
    metrics = {
        'steps_for_target': total_steps,
        'total_steps': total_steps,
        'avg_steps_per_route': avg_steps,
        'valid_routes': valid_routes
    }
    
    return metrics, all_stats

# ============================================================================
# MAIN OPTIMIZATION
# ============================================================================

def optimize_single_route(route: Tuple, character, all_items, items_by_slot, gear_slots, tool_slots, all_slots):
    """Optimize gearset for a single route."""
    
    # Get route requirements from keyword_counts (new format)
    route_info = RAW_ROUTES.get(route)
    required_keywords = {}
    if route_info:
        if 'keyword_counts' in route_info:
            required_keywords = route_info['keyword_counts']
        elif 'requires' in route_info:
            # Handle legacy format
            requirement = route_info['requires']
            if isinstance(requirement, str):
                if requirement == 'skis':
                    required_keywords['skis'] = 1
                elif requirement == 'diving_gear':
                    required_keywords['diving gear'] = 3
                elif '2_light_sources' in requirement:
                    required_keywords['light source'] = 2
                elif '3_light_sources' in requirement:
                    required_keywords['light source'] = 3
    
    # Create scoring function for this route
    def score_function(gearset_dict):
        metrics, stats = calculate_travel_metrics(gearset_dict, [route], character)
        return metrics
    
    # Create validation function
    from util.gearset_utils import is_gearset_valid
    def validate_function(gearset_dict, check_route_requirements=True):
        # Basic validation (UUID, keywords)
        if not is_gearset_valid(gearset_dict, character, activity=None, service=None, check_requirements=False):
            return False
        # Check route requirements
        if check_route_requirements:
            return meets_route_requirements(gearset_dict, route, character)
        return True
    
    # Greedy initialization with keyword tracking (like activity optimizer)
    gearset = {}
    
    # Track how many of each keyword we've added
    current_keyword_counts = {kw: 0 for kw in required_keywords.keys()}
    
    # Fill gear slots
    for slot in gear_slots:
        # Check which keywords we still need
        needed_keywords = {kw for kw, required in required_keywords.items() 
                          if current_keyword_counts[kw] < required}
        
        best_item = None
        best_score = None
        
        for item in items_by_slot.get(slot, []):
            if item is None:
                continue
            
            test_gearset = gearset.copy()
            test_gearset[slot] = item
            
            if not validate_function(test_gearset, check_route_requirements=False):
                continue
            
            try:
                metrics = score_function(test_gearset)
                metric_value = metrics[SORTING_PRIORITY[0].metric_key]
                
                # Boost items with needed keywords (prioritize meeting requirements)
                has_needed_keyword = False
                if hasattr(item, 'keywords') and needed_keywords:
                    for keyword in needed_keywords:
                        if any(keyword.lower() in kw.lower() for kw in item.keywords):
                            has_needed_keyword = True
                            break
                
                # Apply strong boost for items with needed keywords
                if has_needed_keyword:
                    if SORTING_PRIORITY[0].is_reverse:
                        metric_value *= 10000  # Strong boost for maximize
                    else:
                        metric_value /= 10000  # Strong boost for minimize
                
                if best_score is None or (SORTING_PRIORITY[0].is_reverse and metric_value > best_score) or (not SORTING_PRIORITY[0].is_reverse and metric_value < best_score):
                    best_item = item
                    best_score = metric_value
            except:
                continue
        
        gearset[slot] = best_item
        
        # Update keyword counts
        if best_item:
            for kw in required_keywords.keys():
                if item_has_keyword(best_item, kw):
                    current_keyword_counts[kw] += 1
    
    # Fill tool slots
    for slot in tool_slots:
        # Check which keywords we still need
        needed_keywords = {kw for kw, required in required_keywords.items() 
                          if current_keyword_counts[kw] < required}
        
        best_item = None
        best_score = None
        
        for item in items_by_slot.get(slot, []):
            if item is None:
                continue
            
            test_gearset = gearset.copy()
            test_gearset[slot] = item
            
            if not validate_function(test_gearset, check_route_requirements=False):
                continue
            
            try:
                metrics = score_function(test_gearset)
                metric_value = metrics[SORTING_PRIORITY[0].metric_key]
                
                # Boost items with needed keywords
                has_needed_keyword = False
                if hasattr(item, 'keywords') and needed_keywords:
                    for keyword in needed_keywords:
                        if any(keyword.lower() in kw.lower() for kw in item.keywords):
                            has_needed_keyword = True
                            break
                
                # Apply strong boost
                if has_needed_keyword:
                    if SORTING_PRIORITY[0].is_reverse:
                        metric_value *= 10000
                    else:
                        metric_value /= 10000
                
                if best_score is None or (SORTING_PRIORITY[0].is_reverse and metric_value > best_score) or (not SORTING_PRIORITY[0].is_reverse and metric_value < best_score):
                    best_item = item
                    best_score = metric_value
            except:
                continue
        
        gearset[slot] = best_item
        
        # Update keyword counts
        if best_item:
            for kw in required_keywords.keys():
                if item_has_keyword(best_item, kw):
                    current_keyword_counts[kw] += 1
    
    # Local search refinement
    current_metrics = score_function(gearset)
    iteration = 0
    improved = True
    
    # Identify diving gear slots for 2-swap optimization
    diving_gear_slots = ['head', 'chest', 'legs', 'back']
    
    while improved and iteration < MAX_ITERATIONS:
        improved = False
        iteration += 1
        
        best_gearset_metrics = current_metrics
        best_swap = None
        best_swap_gearset = None
        best_swap_metrics = None
        
        # Phase 1: Test single-item swaps
        for slot in all_slots:
            current_item = gearset.get(slot)
            
            for item in items_by_slot.get(slot, []):
                if item is current_item:
                    continue
                
                test_gearset = gearset.copy()
                
                # If item is already in another slot, remove it first
                if item is not None and hasattr(item, 'uuid'):
                    for other_slot in all_slots:
                        if other_slot != slot:
                            other_item = gearset.get(other_slot)
                            if other_item and hasattr(other_item, 'uuid') and other_item.uuid == item.uuid:
                                test_gearset[other_slot] = None
                                break
                
                test_gearset[slot] = item
                
                if not validate_function(test_gearset, check_route_requirements=True):
                    continue
                
                try:
                    test_metrics = score_function(test_gearset)
                    
                    if Sorting.is_better(test_metrics, best_gearset_metrics, SORTING_PRIORITY):
                        best_swap = (slot, current_item, item)
                        best_swap_gearset = test_gearset.copy()
                        best_swap_metrics = test_metrics
                        best_gearset_metrics = test_metrics
                        improved = True
                except:
                    continue
        
        # Apply best 1-swap if found
        if improved and best_swap:
            gearset = best_swap_gearset
            current_metrics = best_swap_metrics
            continue
        
        # Phase 2: If no 1-item swap helped, try 2-item swaps (for any keyword requirements)
        if not improved and required_keywords:
            # Test 2-swaps for any combination of slots
            # This allows swapping diving gear item + non-diving gear item
            for slot1 in all_slots:
                if slot1 not in gearset:
                    continue
                
                for slot2 in all_slots:
                    if slot2 <= slot1 or slot2 not in gearset:  # Only test each pair once
                        continue
                    
                    current_item1 = gearset.get(slot1)
                    current_item2 = gearset.get(slot2)
                    
                    for item1 in items_by_slot.get(slot1, []):
                        if item1 is current_item1:
                            continue
                        
                        for item2 in items_by_slot.get(slot2, []):
                            if item2 is current_item2:
                                continue
                            
                            # Try swapping both items
                            test_gearset = gearset.copy()
                            test_gearset[slot1] = item1
                            test_gearset[slot2] = item2
                            
                            if not validate_function(test_gearset, check_route_requirements=True):
                                continue
                            
                            try:
                                test_metrics = score_function(test_gearset)
                                
                                if Sorting.is_better(test_metrics, best_gearset_metrics, SORTING_PRIORITY):
                                    gearset = test_gearset
                                    current_metrics = test_metrics
                                    best_gearset_metrics = test_metrics
                                    improved = True
                                    break
                            except:
                                continue
                        
                        if improved:
                            break
                    
                    if improved:
                        break
                
                if improved:
                    break
    
    return gearset, current_metrics, iteration

def optimize_travel(test_routes):
    """Optimize gearsets for each route individually."""
    character = get_character()
    
    # Get tool slots based on character level
    from util.walkscape_constants import character_level_from_steps, tool_slots_for_level
    total_steps_char = sum(character.skills.values())
    char_level = character_level_from_steps(total_steps_char)
    max_tool_slots = tool_slots_for_level(char_level)
    
    # Define all slots
    gear_slots = ['head', 'cape', 'neck', 'chest', 'hands', 'legs', 'feet',
                  'ring1', 'ring2', 'back', 'primary', 'secondary']
    tool_slots = [f'tool{i}' for i in range(max_tool_slots)]
    all_slots = gear_slots + tool_slots
    
    # Get all items with travel stats OR no negative stats
    all_items = []
    excluded_count = 0
    for item, qty in character.items.items():
        if qty == 0 or not hasattr(item, 'slot'):
            continue
        if item in IGNORED_ITEMS:
            continue
        
        # Check if unlocked
        if hasattr(item, 'is_unlocked'):
            if not item.is_unlocked(character, ignore_gear_requirements=True):
                excluded_count += 1
                continue
        
        # Check if has travel stats OR no negative WE
        has_stats = False
        for route in test_routes:
            stats = item.get_stats_for_skill('travel', location=route[0], character=character)
            # Include if: has any travel stat, OR has no negative WE
            if any(stats.get(stat, 0) != 0 for stat in ['work_efficiency', 'double_action', 'steps_add', 'steps_percent']):
                # Has travel stats - include if WE is not negative
                if stats.get('work_efficiency', 0) >= 0:
                    has_stats = True
                    break
            else:
                # No travel stats - include it (neutral is better than negative)
                has_stats = True
                break
        
        if has_stats:
            all_items.append(item)
    
    # Keep highest quality only
    all_items = filter_items_by_quality(all_items, keep_highest_only=True)
    
    print(f"Found {len(all_items)} items ({excluded_count} locked)")
    
    # Prepare items by slot
    items_by_slot = {}
    for slot in all_slots:
        items_by_slot[slot] = []
        
        for item in all_items:
            # Match slot
            if slot.startswith('tool') and item.slot == 'tools':
                items_by_slot[slot].append(item)
            elif slot.startswith('ring') and item.slot == 'ring':
                items_by_slot[slot].append(item)
            elif item.slot == slot:
                items_by_slot[slot].append(item)
    
    # Optimize each route individually
    route_results = {}
    
    for route in test_routes:
        route_str = f"{route[0].name} → {route[1].name}"
        if VERBOSE:
            print(f"\nOptimizing {route_str}...")
        
        gearset, metrics, iterations = optimize_single_route(
            route, character, all_items, items_by_slot, 
            gear_slots, tool_slots, all_slots
        )
        
        route_results[route] = {
            'gearset': gearset,
            'metrics': metrics,
            'iterations': iterations
        }
        
        if VERBOSE:
            print(f"  Converged in {iterations} iterations")
            print(f"  Steps: {metrics.get('total_steps', 0):.0f}")
    
    return route_results

# ============================================================================
# DISPLAY FUNCTIONS
# ============================================================================

def print_results(route_results, character, test_routes):
    """Print optimization results with aggregated gearsets."""
    print("\n" + "=" * 80)
    print("TRAVEL OPTIMIZATION COMPLETE")
    print("=" * 80)
    
    priority_names = ' > '.join(s.display_name for s in SORTING_PRIORITY)
    print(f"\nOptimization goal: {priority_names}")
    print(f"Optimized {len(route_results)} routes individually")
    
    # Show per-route results
    print(f"\n{'Route':<50} {'Steps':>10} {'Status':>10}")
    print("-" * 70)
    
    total_steps = 0
    for route in test_routes:
        route_str = f"{route[0].name} → {route[1].name}"
        
        if route in route_results:
            result = route_results[route]
            steps = result['metrics'].get('total_steps', 0)
            total_steps += steps
            print(f"{route_str:<50} {steps:>10.0f} {'OK':>10}")
        else:
            print(f"{route_str:<50} {'N/A':>10} {'BLOCKED':>10}")
    
    print(f"\n{'Total steps for all routes:':<50} {total_steps:>10.0f}")
    print(f"{'Average steps per route:':<50} {total_steps/len(route_results):>10.1f}")
    
    # Group routes by identical gearsets
    print("\n" + "=" * 80)
    print("GEARSETS BY ROUTE GROUP")
    print("=" * 80)
    
    # Create gearset signatures (export strings are unique per gearset)
    gearset_groups = {}
    for route, result in route_results.items():
        export_str = encode_gearset(result['gearset'])
        if export_str not in gearset_groups:
            gearset_groups[export_str] = {
                'routes': [],
                'gearset': result['gearset'],
                'metrics': result['metrics'],
                'iterations': result['iterations']
            }
        gearset_groups[export_str]['routes'].append(route)
    
    # Display grouped gearsets
    for group_num, (export_str, group_data) in enumerate(gearset_groups.items(), 1):
        routes = group_data['routes']
        gearset = group_data['gearset']
        metrics = group_data['metrics']
        iterations = group_data['iterations']
        
        print(f"\nGearset {group_num} - Used by {len(routes)} route(s):")
        for route in routes:
            route_str = f"{route[0].name} → {route[1].name}"
            result = route_results[route]
            steps = result['metrics'].get('total_steps', 0)
            print(f"  • {route_str:<50} {steps:>6.0f} steps")
        
        print(f"\n  Items:")
        for slot in sorted(gearset.keys()):
            item = gearset[slot]
            if item:
                print(f"    {slot:<12} {item.name}")
        
        print(f"\nExport:")
        print(f"{export_str}")
        
        if VERBOSE:
            print(f"  Converged in {iterations} iterations")
    
    # Show aggregated summary
    print("\n" + "=" * 80)
    print("AGGREGATED ITEM USAGE")
    print("=" * 80)
    
    # Count item usage per slot
    slot_item_counts = {}
    for route, result in route_results.items():
        gearset = result['gearset']
        for slot, item in gearset.items():
            if item is not None:
                if slot not in slot_item_counts:
                    slot_item_counts[slot] = {}
                item_name = item.name
                slot_item_counts[slot][item_name] = slot_item_counts[slot].get(item_name, 0) + 1
    
    # Show most common item per slot
    print(f"\n{'Slot':<15} {'Most Common Item':<40} {'Used in Routes':>15}")
    print("-" * 70)
    
    for slot in sorted(slot_item_counts.keys()):
        items = slot_item_counts[slot]
        most_common_item = max(items.items(), key=lambda x: x[1])
        item_name, count = most_common_item
        print(f"{slot:<15} {item_name:<40} {count}/{len(route_results):>15}")

# ============================================================================
# MAIN LOGIC
# ============================================================================

def main():
    """Main optimization logic."""
    start_time = time.time()
    
    # Generate routes from TEST_LOCATIONS
    TEST_ROUTES = get_test_routes()
    
    print("=" * 80)
    print("TRAVEL GEARSET OPTIMIZER - Per-Route Optimization")
    print("=" * 80)
    
    print(f"\nOptimizing for {len(TEST_ROUTES)} routes:")
    for route in TEST_ROUTES[:5]:
        print(f"  {route[0].name} → {route[1].name}")
    if len(TEST_ROUTES) > 5:
        print(f"  ... and {len(TEST_ROUTES) - 5} more routes")
    
    # Optimize each route
    route_results = optimize_travel(TEST_ROUTES)
    
    # Print results
    elapsed = time.time() - start_time
    print(f"\nOptimization completed in {elapsed:.1f} seconds")
    
    character = get_character()
    print_results(route_results, character, TEST_ROUTES)

# ============================================================================
# ENTRY POINT
# ============================================================================

if __name__ == '__main__':
    main()
